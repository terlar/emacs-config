#+TITLE: Emacs Configuration
#+AUTHOR: Terje Larsen
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

* Introduction
terlar's Emacs Configuration. It is not very well documented right now, but hopefully I
will have time to write down some more details later.

The rough details:
- theme :: [[https://github.com/11111000000/tao-theme-emacs][tao-theme]] (yang) with [[file:lisp/local-theme.el][some local modifications]]
  - fonts :: [[https://github.com/be5invis/Iosevka][Iosevka Slab]], Noto Sans, Noto Serif
  - semantic highlighting :: [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]], [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]] (fallback, with wider support)
- menu completion :: [[https://github.com/abo-abo/swiper][ivy]]
- +buffer completion :: [[https://github.com/company-mode/company-mode][company-mode]], [[https://github.com/tumashu/company-childframe][company-childframe]]+
- +modal editing (vi) :: [[https://github.com/emacs-evil/evil][evil]]+
- package configuration :: [[https://github.com/jwiegley/use-package][use-package]]
- key definitions :: [[https://github.com/noctuid/general.el][general]]
- code navigation :: [[https://github.com/jacktasia/dumb-jump][dumb-jump]], [[https://github.com/jojojames/smart-jump][smart-jump]], [[https://github.com/iqbalansari/emacs-source-peek][source-peek]]
- syntax checker :: flymake
- persistent undo :: via built-in =desktop-save-mode=

** Screenshots
*** org-mode
#+CAPTION: org-mode
[[file:media/org-mode.png]]

*** markdown-mode
#+CAPTION: markdown-mode
[[file:media/markdown-mode.png]]

*** emacs-lisp-mode
#+CAPTION: emacs-lisp-mode
[[file:media/emacs-lisp-mode.png]]

* The beginning
Every good file starts with a nice header and enable lexical scoping as per the
recommendations of the [[https://github.com/bbatsov/emacs-lisp-style-guide#source-code-layout--organization][The Emacs Lisp Style Guide]].
#+BEGIN_SRC emacs-lisp
;;; init.el --- Emacs Initialization -*- lexical-binding: t; -*-
#+END_SRC

** Variables
Provide an easy way to toggle debug mode which will set certain variables to produce more
informative output. It can be set either by providing the environment variable =DEBUG= or
start Emacs with =--debug-init=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar +debug-mode
    (or (getenv "DEBUG") init-file-debug)
    "Debug mode, enable through DEBUG=1 or use --debug-init.")
  (setq debug-on-error (and (not noninteractive) +debug-mode)))
#+END_SRC

Provide a location where Emacs can store data and cache.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar +data-dir
    (if (getenv "XDG_DATA_HOME")
        (concat (getenv "XDG_DATA_HOME") "/emacs/")
      (expand-file-name "~/.local/share/emacs/"))
    "Directory for data.")

  (defvar +cache-dir
    (if (getenv "XDG_CACHE_HOME")
        (concat (getenv "XDG_CACHE_HOME") "/emacs/")
      (expand-file-name "~/.cache/emacs/"))
    "Directory for cache."))
#+END_SRC

** Quiet startup
#+BEGIN_SRC emacs-lisp
(setq inhibit-default-init t
      inhibit-startup-screen t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
#+END_SRC

** UX
Disable bell (both visual and audible)
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore
      visible-bell nil)
#+END_SRC

Use =y= / =n= instead of =yes= / =no=
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs #'y-or-n-p)
(fset #'yes-or-no-p #'y-or-n-p)
#+END_SRC

** Custom file
Put custom defs in a temporary file so it doesn't grow over time.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" temporary-file-directory))
#+END_SRC

** Load path
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path
        (append (delete-dups load-path)
                (list (expand-file-name "lisp" user-emacs-directory)
                      (expand-file-name "private" user-emacs-directory)))))
#+END_SRC

** Shell
Set shell to bash as fish is not compatible with all packages using the shell.
#+BEGIN_SRC emacs-lisp
(setq shell-file-name "bash")
#+END_SRC

** Package management
Don't use defualt =package.el=:
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC

*** use-package
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
(setq use-package-always-defer t)

(if +debug-mode
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+END_SRC

** Packages
*** no-littering
Help keeping =~/.emacs.d= clean.
#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :demand t
  :preface
  (defvar no-littering-etc-directory +data-dir)
  (defvar no-littering-var-directory +cache-dir))
#+END_SRC

*** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :demand t
  :custom
  (exec-path-from-shell-check-startup-files nil)
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

*** server
#+BEGIN_SRC emacs-lisp
(use-package server
  :commands
  (server-running-p)
  :preface
  (defun +server-ensure-running (frame)
    "Ensure server is running when launching FRAME."
    (with-selected-frame frame
      (unless (server-running-p)
        (server-start))))
  :init
  (add-hook 'after-make-frame-functions #'+server-ensure-running))
#+END_SRC

*** savehist
Persist history.
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :custom
  (savehist-additional-variables
   '(kill-ring
     search-ring
     regexp-search-ring))
  (savehist-autosave-interval 60)
  (savehist-save-minibuffer-history t)
  :init
  (savehist-mode 1))
#+END_SRC

** Libraries
*** cl-lib
#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
#+END_SRC

*** async
#+BEGIN_SRC emacs-lisp
(use-package async :demand t)
#+END_SRC

*** flymake-quickdef
#+BEGIN_SRC emacs-lisp
(use-package flymake-quickdef)
#+END_SRC

*** posframe
#+BEGIN_SRC emacs-lisp
(use-package posframe
  :custom
  (posframe-mouse-banish nil))
#+END_SRC

** Tangling
Support auto-tangling via =auto-tangle-mode=.
#+BEGIN_SRC emacs-lisp
(require 'auto-tangle)
#+END_SRC

* Base
** Performance
Disable bidirectional text for tiny performance boost
#+BEGIN_SRC emacs-lisp
(setq-default bidi-display-reordering nil)
#+END_SRC

Update UI less frequently
#+BEGIN_SRC emacs-lisp
(setq idle-update-delay 2
      jit-lock-defer-time 0
      jit-lock-stealth-time 0.2
      jit-lock-stealth-verbose nil)
#+END_SRC

** Localization
#+BEGIN_SRC emacs-lisp
(setq-default calendar-week-start-day 1)
#+END_SRC

** Terminal
*** Pager
Make less work inside Emacs shells. But disable it as the default pager.
#+BEGIN_SRC emacs-lisp
(setenv "LESS" "--dumb --prompt=s")
(setenv "PAGER" "")
#+END_SRC

** Packages
*** all-the-icons
Support functions for displaying icons. I am trying to use icons where possible.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :demand t)
#+END_SRC

*** auto-minor-mode
Enable minor modes by buffer name and contents. It provides the =use-package= keyword
=:minor= and =:magic-minor= where you can specify these rules.
#+BEGIN_SRC emacs-lisp
(use-package auto-minor-mode :demand t)
#+END_SRC

*** defrepeater
Support defining repeating commands by repeating the last key.
#+BEGIN_SRC emacs-lisp
(use-package defrepeater)
#+END_SRC

*** diminish
Hide mode-line modes, more room for important stuff.
#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

*** general
More convenient key definitions. I provides the =use-package= keyword =:general=.
#+BEGIN_SRC emacs-lisp
(use-package general :demand t)
#+END_SRC

*** hide-lines
#+BEGIN_SRC emacs-lisp
(use-package hide-lines)
#+END_SRC

*** minions
#+BEGIN_SRC emacs-lisp
(use-package minions
  :general
  ([C-S-mouse-1] 'minions-minor-modes-menu))
#+END_SRC

*** quick-peek
Library to display inline popups; used by =source-peek=.
#+BEGIN_SRC emacs-lisp
(use-package quick-peek)
#+END_SRC

*** vlf
Large file support. This can view/edit/search and compare large files.
#+BEGIN_SRC emacs-lisp
(use-package vlf)
#+END_SRC

*** which-key
Display available keybindings in a popup.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 1
  :diminish which-key-mode
  :custom
  (which-key-sort-order #'which-key-key-order-alpha)
  (which-key-sort-uppercase-first nil)
  (which-key-add-column-padding 1)
  (which-key-min-display-lines 5)
  (which-key-idle-delay 1)
  :config
  (dolist (item '((("<\\([[:alnum:]-]+\\)>" . nil) . ("\\1" . nil))
                  (("\\`\\?\\?\\'" . nil) . ("λ" . nil))
                  (("<up>" . nil) . ("↑" . nil))
                  (("<right>" . nil) . ("→" . nil))
                  (("<down>" . nil) . ("↓" . nil))
                  (("<left>" . nil) . ("←" . nil))
                  (("SPC" . nil) . ("␣" . nil))
                  (("TAB" . nil) . ("↹" . nil))
                  (("RET" . nil) . ("⏎" . nil))
                  (("DEL" . nil) . ("⌫" . nil))
                  (("deletechar" . nil) . ("⌦" . nil))))
    (cl-pushnew item which-key-replacement-alist :test #'equal))

  (which-key-setup-side-window-bottom)

  (which-key-mode 1))
#+END_SRC

** Functions
Prevent forms from producing output or other noise.
#+BEGIN_SRC emacs-lisp
(defmacro quiet! (&rest forms)
  "Run FORMS without making any noise."
  `(if +debug-mode
       (progn ,@forms)
     (let ((message-log-max nil))
       (with-temp-message (or (current-message) "") ,@forms))))

(defun quiet-function-advice (orig-fn &rest args)
  "Advice used to make a function quiet.
Call ORIG-FN with ARGS and suppress the output.

Example:
  (advice-add #'orig-fun :around #'quiet-function-advice)"
  (quiet! (apply orig-fn args)))
#+END_SRC

Run forms when graphical frame is created.
#+BEGIN_SRC emacs-lisp
(defmacro eval-after-make-graphic-frame (hook-id &rest forms)
  "Run HOOK-ID hook with FORMS after making a frame on a graphic display.
   Add a hook to `after-make-frame-functions' with form wrapped in a
   `display-graphic-p' condition."
  (let ((hook-name (intern
                    (concat
                     "+eval-after-make-graphic-frame--"
                     hook-id
                     "-hook"))))
    `(progn
       (defun ,hook-name (frame)
         (with-selected-frame frame
           (when (display-graphic-p frame)
             ,@forms)))
       (add-hook 'after-make-frame-functions #',hook-name))))
#+END_SRC

*** Display
#+BEGIN_SRC emacs-lisp
(defun display-ctrl-M-as-newline ()
  "Display `^M' as newline."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M [?\n]))
#+END_SRC

*** Editing
#+BEGIN_SRC emacs-lisp
(defun turn-on-truncate-lines ()
  "Enable `truncate-lines' for the current buffer."
  (setq truncate-lines t))

(defun turn-off-truncate-lines ()
  "Disable `truncate-lines' for the current buffer."
  (setq truncate-lines nil))
#+END_SRC

*** Process
#+BEGIN_SRC emacs-lisp
(defun send-buffer-to-ssh ()
  "Send the whole buffer to the *ssh* process."
  (interactive)
  (process-send-region "*ssh*" (point-min) (point-max)))

(defun send-to-ssh ()
  "Send selected region or current line to the *ssh* process."
  (interactive)
  (let ((procbuf "*ssh*"))
    (if (use-region-p)
        (process-send-region procbuf (region-beginning) (region-end))
      (process-send-string procbuf (thing-at-point 'line t)))))
#+END_SRC

*** Utils
#+BEGIN_SRC emacs-lisp
(defcustom work-log-directory "~/org"
  "Directory where work log files are stored."
  :type 'file-name-directory
  :group 'local)

(defcustom work-log-file-name-pattern "worklog-%s.org"
  "File name pattern for work log files."
  :type 'string
  :group 'local)

(defcustom work-log-daily-tasks nil
  "Daily tasks that will be added to each new work log file."
  :type '(repeat string)
  :group 'local)

(defun work-log-time-from-file-name ()
  "Returns the time from the time string in the buffer file name."
  (let ((file-name (when-let* ((f (buffer-file-name)))
                     (file-truename f)))
        (regexp (concat
                 "^"
                 (expand-file-name
                  (concat
                   (regexp-quote (file-truename work-log-directory))
                   "/"
                   (format (regexp-quote work-log-file-name-pattern)
                           "\\([0-9]\\{4\\}-\\(0[0-9]\\|1[0-2]\\)-\\([0-2][0-9]\\|3[01]\\)\\)")))
                 "$")))
    (when (and file-name (string-match regexp file-name))
      (apply 'encode-time (org-parse-time-string (match-string 1 file-name))))))

(defun work-log-file-name (&optional time)
  "Returns file name of the work log corresponding to TIME.
When TIME is nil the target is today's work log."
  (expand-file-name
   (concat (file-truename work-log-directory)
           "/"
           (format work-log-file-name-pattern (format-time-string "%Y-%m-%d" time)))))

(defun work-log-file (&optional time)
  "Edit work log file.

Switch to a buffer visiting work log file,
creating one if none already exists.

Today's work log, or if TIME is non-nil a work log corresponding
to TIME."
  (interactive)
  (find-file (work-log-file-name time)))

(defun work-log-file-previous ()
  "Edit previous work log file.

Switch to a buffer visiting previous work log file,
fall-back to today's work log file if none already exists."
  (interactive)
  (let ((time (work-log-time-from-file-name))
        (day-in-seconds (* 24 3600)))
    (work-log-file (when time (time-subtract time day-in-seconds)))))

(defun work-log-file-next ()
  "Edit next work log file.

Switch to a buffer visiting next work log file,
fall-back to today's work log file if none already exists."
  (interactive)
  (let ((time (work-log-time-from-file-name))
        (day-in-seconds (* 24 3600)))
    (work-log-file (when time (time-add time day-in-seconds)))))

(defun sprint-file ()
  "Open current sprint log file."
  (interactive)
  (let ((sprint-name (format-time-string "%Y-W%W")))
    (find-file (expand-file-name (concat "~/org/sprint-" sprint-name ".org")))))
#+END_SRC

*** Window
#+BEGIN_SRC emacs-lisp
(defun toggle-dedicated-window ()
  "Toggle selected window as dedicated window."
  (interactive)
  (set-window-dedicated-p (selected-window)
                          (not (window-dedicated-p (selected-window)))))
#+END_SRC

* Keybindings
I am trying to reduce the amount of keybindings, therefore I present a table of default
keybindings in case I would forget them.

| Keybinding | Alternative |
|------------+-------------|
| =M-=         | =C-[=         |
| =TAB=        | =C-i=         |
| =RET=        | =C-j=         |

| Keybinding      | Function                        | Description                                                                      |
|-----------------+---------------------------------+----------------------------------------------------------------------------------|
| =C-o=             | =open-line=                       | Open line below                                                                  |
| =M-SPC=           | =just-one-space=                  | Ensures just one space                                                           |
| =M-\=             | =delete-horizontal-space=         | Delete all space                                                                 |
| =M-^=             | =delete-indentation=              | Join current line with previous line                                             |
| =M-z=             | =zap-to-char=                     | Delete until character                                                           |
| =C-S-backspace=   | =kill-whole-line=                 | Kill entire lines, can be used to move several lines at once                     |
| =M-/=             | =dabbrev-expand=                  | Abbreviation completion                                                          |
| =M-tab= / =C-[ C-i= | =completion-at-point= / =pcomplete= | More context aware completion                                                    |
| =C-w=             | =kill-region=                     | Cut                                                                              |
| =M-w=             | =kill-ring-save=                  | Copy                                                                             |
| =C-y=             | =yank=                            | Paste                                                                            |
| =M-y=             | =yank-next=                       | Paste (next item)                                                                |
| =C-x SPC=         | =rectangle-mark-mode=             | Rectangular selection                                                            |
| =C-x r t=         | =string-rectangle=                | Insert string in beginning of rectangular selection (=C-t= in =rectangle-mark-mode=) |
| =C-M-f=           | =forward-sexp=                    | Move forward inside a balanced expression                                        |
| =C-M-b=           | =backward-sexp=                   | Move backward inside a balanced expression                                       |
| =C-M-n=           | =forward-list=                    | Move forward across one balanced group of parenthesis                            |
| =C-M-p=           | =backward-list=                   | Move backward across one balanced group of parenthesis                           |
| =M-m=             | =back-to-indentation=             | Move to the first non-whitespace character                                       |
| =M-e=             | =forward-sentence=                | End of sentence                                                                  |
| =M-a=             | =backward-sentence=               | Start of sentence                                                                |
| =C-M-d=           | =down-list=                       | Move forward down one level of parenthesis                                       |
| =C-M-u=           | =backward-up-list=                | Move backward out of one level of parenthesis                                    |

** Ivy
| Keybinding | Function           | Description                                              |
|------------+--------------------+----------------------------------------------------------|
| =C-M-j=      | =ivy-immediate-done= | Accept input without selecting, (e.g. for new file name) |

** Leader keys
#+BEGIN_SRC emacs-lisp
(defvar +leader-key "C-,"
  "The key used for most custom operations.")
(defvar +local-leader-key "C-."
  "The key used for major mode operations.")
(defvar +evil-normal-state-leader-key "SPC"
  "The key used for most custom operations in `evil-normal-state'.")
#+END_SRC

** Prefixes
#+BEGIN_SRC emacs-lisp
(defvar +launch-prefix "C-c l"
  "Key prefix for commands related to launching.")

(defvar +toggle-prefix "C-x t"
  "Key prefix for commands related to toggling.")
(defvar +window-prefix "C-'"
  "Key prefix used for commands related to window operations.")

(defvar +nav-prefix "M-g"
  "Key prefix used for commands related to navigation.")
(defvar +search-prefix "M-s"
  "Key prefix used for commands related to search.")

(defvar +next-prefix "M-]"
  "Key prefix used for commands doing a next operation.")
(defvar +prev-prefix "M-["
  "Key prefix used for commands doing a previous operation.")
#+END_SRC

** Global
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 ;; Editing
 "C-z" 'zap-up-to-char
 ;; Files
 "C-c o" 'ff-find-other-file
 "C-c O" 'ff-test-find-other-file
 ;; Terminal
 "C-!" 'eshell
 "C-M-!" '(lambda () (interactive) (term "fish"))
 ;; Window
 "C-`" 'window-toggle-side-windows)
#+END_SRC

** Navigation
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 :prefix +nav-prefix
 "u" 'browse-url)
#+END_SRC

** Window
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 :prefix +window-prefix
 +window-prefix 'window-toggle-side-windows
 "d" 'toggle-dedicated-window
 "m" 'maximize-window)
#+END_SRC

** Next
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix +next-prefix
 ""  '(:ignore t :wk "next...")
 "]" `(,(defrepeater #'text-scale-increase)      :wk "Text size")
 "b" `(,(defrepeater #'next-buffer)              :wk "Buffer")
 "c" `(,(defrepeater #'smerge-next)              :wk "Conflict")
 "d" `(,(defrepeater #'diff-hl-next-hunk)        :wk "Diff Hunk")
 "e" `(,(defrepeater #'next-error)               :wk "Error")
 "s" `(,(defrepeater #'flyspell-goto-next-error) :wk "Spell error")
 "t" `(,(defrepeater #'hl-todo-next)             :wk "Todo")
 "w" `(,(defrepeater #'work-log-file-next)       :wk "Work Log"))
#+END_SRC

** Previous
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix +prev-prefix
 ""  '(:ignore t :wk "previous...")
 "[" `(,(defrepeater #'text-scale-decrease)    :wk "Text size")
 "b" `(,(defrepeater #'previous-buffer)        :wk "Buffer")
 "c" `(,(defrepeater #'smerge-prev)            :wk "Conflict")
 "d" `(,(defrepeater #'diff-hl-previous-hunk)  :wk "Diff Hunk")
 "e" `(,(defrepeater #'previous-error)         :wk "Error")
 "t" `(,(defrepeater #'hl-todo-previous)       :wk "Todo")
 "w" `(,(defrepeater #'work-log-file-previous) :wk "Work Log"))
#+END_SRC

** Toggle
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix +toggle-prefix
 "c" '(highlight-changes-mode           :wk "Changes")
 "d" '(toggle-debug-on-error            :wk "Debug on error")
 "f" '(hs-minor-mode                    :wk "Code folding")
 "h" '(hl-line-mode                     :wk "Line highlight")
 "l" '(global-display-line-numbers-mode :wk "Line numbers")
 "s" '(subword-mode                     :wk "Sub-word")
 "t" '(toggle-truncate-lines            :wk "Truncate lines")
 "v" '(variable-pitch-mode              :wk "Variable-pitch")
 "w" '(whitespace-mode                  :wk "White-space")
 "x" '(flymake-mode                     :wk "Syntax checker"))
#+END_SRC

** Launch
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix +launch-prefix
 "m" 'gnus
 "p" 'list-processes
 "x" 'regexp-builder
 "w" 'eww)
#+END_SRC

* Help
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'help-map
 "B" 'find-library
 "u" 'describe-face
 "U" 'list-faces-display
 "'" 'describe-char)
#+END_SRC

* Appearance
** Typography
*** Size
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar +line-spacing 0.25
    "Spacing between lines.")

  (defvar +default-font-height 120
    "Default font height."))
#+END_SRC

*** Face
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar +fixed-pitch-font "Iosevka Slab"
    "Font used for fixed-pitch faces.")

  (defvar +variable-pitch-font "Noto Sans"
    "Font used for variable-pitch faces.")

  (defvar +serif-font "Noto Serif"
    "Font used for serif faces.")

  (defvar +unicode-font "Noto Sans Mono"
    "Fallback font used for unicode glyphs.")

  (defvar +emoji-font "Noto Emoji"
    "Font used for symbol/emoji faces."))

(eval-after-make-graphic-frame
 "setup-emoji-font"
 (set-fontset-font "fontset-default" 'symbol
                   (font-spec :family +emoji-font) nil 'prepend))
#+END_SRC

*** Line length
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 90)
#+END_SRC

** Theme
*** tao-theme (tao-yang)
An excellent, light, uncolored theme.
#+BEGIN_SRC emacs-lisp
(use-package tao-theme
  :demand t
  :custom
  (tao-theme-use-sepia t))

(use-package berrys-theme :demand t)

(load-theme 'berrys t)
#+END_SRC

*** Local overrides
No theme is perfect, also this is a good place to put my own experiments.
#+BEGIN_SRC emacs-lisp
(use-package local-theme
  :custom
  (local-theme-default-font-height +default-font-height)
  (local-theme-line-spacing +line-spacing)
  (local-theme-fixed-pitch-font +fixed-pitch-font)
  (local-theme-variable-pitch-font +variable-pitch-font)
  (local-theme-serif-font +serif-font))

(defvar after-load-theme-hook nil
  "Hook run after a theme is loaded using `load-theme'.")
(defun +load-theme-run-after-load-theme-hooks (&rest args)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))
(advice-add 'load-theme :after #'+load-theme-run-after-load-theme-hooks)

(defun +local-theme-ensure ()
  "Ensure `local-theme' is loaded."
  (unless (member 'local custom-enabled-themes)
    (load-theme 'local t)))
(setq after-load-theme-hook '(+local-theme-ensure))

(eval-after-make-graphic-frame
 "load-local-theme"
 (require 'local-theme)
 (load-theme 'local t))
#+END_SRC

*** Echo area
Adjust the font face used for the echo area.
#+BEGIN_SRC emacs-lisp
(dolist (buffer-name '(" *Echo Area 0*"
                       " *Echo Area 1*"))
  (with-current-buffer (get-buffer-create buffer-name)
    (setq-local face-remapping-alist
                '((default (:height 0.9) variable-pitch)))))
#+END_SRC

** Layout
*** Frame
See [[info:elisp#Frame%20Layout][Frame Layout]] documentation for details and terminology.
- Add some padding around the whole window (=internal-border-width=) to provide some air.
- Remove GUI elements.
- Maximize the window; A maximized window ensures macOS won't waste extra space all-though
  it is technically not maximized.
- Make the title-bar transparent on macOS.
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist
      '((internal-border-width . 16)
        (vertical-scroll-bars . nil)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)))

(when (eq system-type 'darwin)
  (setq frame-title-format nil)
  (dolist (filter '((ns-transparent-titlebar . t)
                    (ns-appearance . unbound)))
    (cl-pushnew filter default-frame-alist :test #'equal)))
#+END_SRC

*** Fringe
Setup fringes on both sides and display an indicator for buffer boundaries on the right
side. Display fringes outside margins to have the [[Padding][padding]] on the inside.
#+BEGIN_SRC emacs-lisp
(setq-default fringes-outside-margins t
              left-fringe-width 8
              right-fringe-width 8
              indicate-buffer-boundaries 'right)
#+END_SRC

*** Padding
Add margins inside windows to make text feel less crowded. Padding around the frame is
configured via the =internal-border-width= in the [[Frame][Frame]] section.
#+BEGIN_SRC emacs-lisp
(setq-default left-margin-width 1
              right-margin-width 1)
#+END_SRC

*** Borders
Add window dividers, mainly to add a border below the mode line.
#+BEGIN_SRC emacs-lisp
(setq window-divider-default-places t
      window-divider-default-bottom-width 1
      window-divider-default-right-width 1)

(eval-after-make-graphic-frame
 "setup-window-divider"
 (window-divider-mode 1))
#+END_SRC

** Mode line
I am trying to keep the original mode line as much as possible to ensure compatibility
with various packages and features, but I have rearranged the position of things and also
introduced a right side mode line. I have defined a helper function to fill up the space
needed to make the mode line appear on the right side.

*** Right alignment
Setup the right aligned mode line and helper functions to display it.
#+BEGIN_SRC emacs-lisp
(defvar mode-line-space
  '(:propertize
    " " display
    ((space :width 1)))
  "Space between mode line components.")

(defvar mode-line-right-format nil
  "The mode line to display on the right side.")

(defun mode-line-right ()
  "Render the `mode-line-right-format'."
  (let ((formatted-line (format-mode-line mode-line-right-format)))
    (list
     (propertize
      " "
      'display `((space :align-to
                        (- (+ right
                              right-fringe
                              right-margin
                              right-margin-width
                              left-fringe
                              left-margin-width)
                           ,(* (string-width formatted-line)
                               0.8)))))
     formatted-line)))

(setq-default mode-line-format
              (append
               mode-line-format
               '((:eval (mode-line-right)))))
#+END_SRC

Move default components to the right side of the mode line.
#+BEGIN_SRC emacs-lisp
(delete 'mode-line-position mode-line-format)
(delete 'mode-line-mule-info mode-line-format)
(delete 'mode-line-modes mode-line-format)

(setq mode-line-right-format
      `(,mode-line-position
        (:eval mode-line-mule-info)
        ,mode-line-space
        ,mode-line-modes))
#+END_SRC

*** Position
Add position information including column and line number but skip the percentage.
#+BEGIN_SRC emacs-lisp
(setq mode-line-percent-position nil)
(column-number-mode 1)
(line-number-mode 1)
#+END_SRC

*** Indentation
Display information about the current indentation settings.
#+BEGIN_SRC emacs-lisp
(use-package indent-info
  :defer 2
  :custom
  (indent-info-insert-target 'mode-line-mule-info)
  (indent-info-prefix " ")
  (indent-info-suffix " ")
  :config
  (global-indent-info-mode 1))
#+END_SRC

*** Hide mode line
Support hiding the mode line, this can be useful for different modes displaying documents
or presentation.
#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line)
#+END_SRC

*** Diminished modes
Hide minor modes to save space.
#+BEGIN_SRC emacs-lisp
(diminish 'abbrev-mode)
(diminish 'auto-fill-function)
(with-eval-after-load 'face-remap (diminish 'buffer-face-mode))
(with-eval-after-load 'with-editor (diminish 'with-editor-mode))
#+END_SRC

*** Icons
**** Modified
#+BEGIN_SRC emacs-lisp
(defun mode-line-modified-icons ()
  "Icon representation of `mode-line-modified'."
  (cond (buffer-read-only
         (concat (all-the-icons-octicon "lock" :v-adjust -0.05) " "))
        ((buffer-modified-p)
         (concat (all-the-icons-faicon "floppy-o" :v-adjust -0.05) " "))
        ((and buffer-file-name
              (not (file-exists-p buffer-file-name)))
         (concat (all-the-icons-octicon "circle-slash" :v-adjust -0.05) " "))))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-modified '((:eval (mode-line-modified-icons)))))
#+END_SRC

**** Remote
#+BEGIN_SRC emacs-lisp
(defun mode-line-remote-icons ()
  "Icon representation of `mode-line-remote'."
  (when (and buffer-file-name
             (file-remote-p buffer-file-name))
    (concat (all-the-icons-octicon "radio-tower" :v-adjust -0.02) " ")))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-remote   '((:eval (mode-line-remote-icons)))))
#+END_SRC

**** VCS
Shorten long Git branch names as well as replace Git prefix with a nice icon.
#+BEGIN_SRC emacs-lisp
(defun +shorten-vc-mode-line (string)
  "Shorten `version-control' STRING in mode-line and add icon."
  (cond
   ((string-prefix-p "Git" string)
    (concat (all-the-icons-octicon "git-branch" :v-adjust -0.05)
            " "
            (if (> (length string) 30)
                (concat (substring-no-properties string 4 30) "…")
              (substring-no-properties string 4))))
   (t
    string)))
(advice-add 'vc-git-mode-line-string :filter-return #'+shorten-vc-mode-line)
#+END_SRC

* Display
** Frame
Don't implicitly resize frames when changes various settings.
#+BEGIN_SRC emacs-lisp
(setq frame-inhibit-implied-resize t)
#+END_SRC

** Window
*** Favor horizontal splits
#+BEGIN_SRC emacs-lisp
(setq split-width-threshold nil)
#+END_SRC

*** Manage layouts
Undo/redo between window layouts.
#+BEGIN_SRC emacs-lisp
(use-package winner
  :hook
  (window-setup . winner-mode)
  :custom
  (winner-dont-bind-my-keys t)
  :config
  (general-define-key
   :prefix +next-prefix
   +next-prefix (defrepeater #'winner-redo))
  (general-define-key
   :prefix +prev-prefix
   +prev-prefix (defrepeater #'winner-undo)))
#+END_SRC

Transpose window arrangement.
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame
  :general
  (:prefix
   +window-prefix
   "t" 'transpose-frame))
#+END_SRC

*** Navigation
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :custom
  (aw-ignore-current t)
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-scope 'frame)
  :general
  ([remap other-window] 'ace-window))
#+END_SRC

*** Zoom
Zoom a window to display as a single window temporarily.
#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :general
  (:prefix
   +window-prefix
   "z" 'zoom-window-zoom))
#+END_SRC

** Buffer
*** Popups
Always display pop up buffers at the bottom and regard all star buffers as such buffers.
#+BEGIN_SRC emacs-lisp
(dolist (rule `((,(rx bos "*" (one-or-more anything) "*" (optional "<" (one-or-more anything) ">") eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side . bottom)
                 (window-height . 0.4))
                ("^*Warn about privacy*" display-buffer-pop-up-window)))
  (cl-pushnew rule display-buffer-alist :test #'equal))
#+END_SRC

*** Hide async shell command buffers
#+BEGIN_SRC emacs-lisp
(cl-pushnew '("^*Async Shell Command*" . (display-buffer-no-window))
            display-buffer-alist
            :test #'equal)
#+END_SRC

*** Visual Fill Column
Wrap lines according to =fill-column= in =visual-line-mode=.
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :custom
  (visual-fill-column-center-text t))
#+END_SRC

* Editing
** Indentation
Default to indentation by spaces, that seems to be what most languages use nowadays.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Convert between tabs and spaces (only tabify initial white-space)
#+BEGIN_SRC emacs-lisp
(setq-default tabify-regexp "^\t* [ \t]+")
#+END_SRC

** Text flow
Wrap at words and don't require double spaces to end a sentence.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
(setq-default word-wrap t)
#+END_SRC

Disable line wrapping. But enable =visual-line-mode= by default to be able to use
=global-visual-fill-column-mode=.
#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
(add-hook 'visual-line-mode-hook #'turn-on-truncate-lines)
(global-visual-line-mode 1)
#+END_SRC

** Kill-ring
Save clipboard contents into kill-ring before replacing them
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

** Packages
*** avy
Jump to things.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :custom
  (avy-all-windows nil)
  :general
  (:prefix
   +search-prefix
   "SPC" 'avy-goto-word-or-subword-1
   "s" 'avy-goto-char
   "l" 'avy-goto-line
   "m" 'avy-pop-mark))
#+END_SRC

*** cycle-quotes
#+BEGIN_SRC emacs-lisp
(use-package cycle-quotes
  :commands
  (cycle-quotes)
  :preface
  (defrepeater #'cycle-quotes)
  :general
  ("C-x C-'" 'cycle-quotes-repeat))
#+END_SRC

*** goto-addr
Buttonize URLs and e-mail addresses in the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook
  (text-mode . goto-address-mode)
  (prog-mode . goto-address-prog-mode))
#+END_SRC

*** parrot
Cycle through words, symbols and patterns.
#+BEGIN_SRC emacs-lisp
(use-package parrot
  :commands
  (parrot-rotate-next-word-at-point
   parrot-rotate-prev-word-at-point)
  :preface
  (defrepeater #'parrot-rotate-next-word-at-point)
  (defrepeater #'parrot-rotate-prev-word-at-point)
  :general
  (:prefix
   +next-prefix
   "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
  (:prefix
   +prev-prefix
   "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
  :config
  (dolist (entry '((:rot ("assert" "refute"))))
    (cl-pushnew entry parrot-rotate-dict :test #'equal)))
#+END_SRC

*** string-inflection-cycle
#+BEGIN_SRC emacs-lisp
(use-package string-inflection
  :general
  ("M-'" 'string-inflection-all-cycle))
#+END_SRC

*** smartparens
Auto-insert matching parenthesis and highlight matching parenthesis.
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish
  (smartparens-mode smartparens-strict-mode)
  :hook
  (eval-expression-minibuffer-setup . smartparens-strict-mode)
  :general
  (:prefix
   +toggle-prefix
   "p" 'smartparens-strict-mode)
  (:keymaps
   'smartparens-mode-map
   "M-D" 'sp-unwrap-sexp
   "M-R" 'sp-rewrap-sexp
   "M-W" 'sp-wrap-round)
  :preface
  (defun +smartparens-no-autoinsert-pair-advice (orig-fn &rest args)
    "Disable command smartparens autoinsert when running ORIG-FN with ARGS."
    (let ((sp-autoinsert-pair nil))
      (apply orig-fn args)))
  :init
  (smartparens-global-strict-mode 1)
  (show-smartparens-global-mode 1)
  :config
  (require 'smartparens-config)

  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*"
                   :actions '(insert wrap)
                   :unless '(sp-point-after-word-p sp-point-at-bol-p)
                   :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "_" "_" :unless '(sp-point-after-word-p)
                   :wrap "C-_")
    (sp-local-pair "/" "/" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "«" "»"))

  (sp-with-modes 'nix-mode
    (sp-local-pair "'" "'"
                   :unless '(sp-in-comment-p
                             sp-in-string-quotes-p))
    (sp-local-pair "\"" "\"")
    (sp-local-pair "''" "''"
                   :unless '(sp-in-comment-p
                             sp-in-string-quotes-p)))

  (with-eval-after-load 'hippie-exp
    (advice-add #'hippie-expand :around #'+smartparens-no-autoinsert-pair-advice)))
#+END_SRC

*** visual-regexp
Visually highlight regular expression searches as you type. Also supports replace.
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :general
  ("M-s r" 'vr/query-replace
   "M-s R" 'vr/replace))
#+END_SRC

*** whitespace
Display whitespace
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :custom
  (whitespace-line-column fill-column)
  (whitespace-style
   '(face tabs tab-mark spaces space-mark trailing lines-tail))
  (whitespace-display-mappings
   '((tab-mark ?\t [?› ?\t])
     (newline-mark 10 [?¬ 10])
     (space-mark 32 [183] [46]))))
#+END_SRC

*** whole-line-or-region
Cut/copy (=C-w= / =M-w=) the current line if no region is active.
#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :diminish whole-line-or-region-local-mode
  :init
  (whole-line-or-region-global-mode 1))
#+END_SRC

*** yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :diminish yas-minor-mode
  :commands
  (yas--templates-for-key-at-point)
  :custom
  (yas-also-auto-indent-first-line t)
  (yas-snippet-dirs (list (expand-file-name "snippets" user-emacs-directory)))
  ;; Nested snippets
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :general
  (:keymaps
   'yas-minor-mode-map
   [tab] 'nil
   "TAB" 'nil
   "M-o" 'yas-insert-snippet)
  :init
  (setq yas-verbosity 0)
  :config
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :hook
  (yas-minor-mode . yasnippet-snippets-initialize))
#+END_SRC

*** yatemplate
#+BEGIN_SRC emacs-lisp
(use-package autoinsert
  :hook
  (after-init . auto-insert-mode)
  :custom
  (auto-insert-query nil))

(use-package yatemplate
  :hook
  (auto-insert-mode . yatemplate-fill-alist))
#+END_SRC

** Appearance
*** Page breaks
Display page breaks as a horizontal line.
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :defer 1
  :diminish page-break-lines-mode
  :config
  (global-page-break-lines-mode 1))
#+END_SRC

*** Line highlight
#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :hook
  ((prog-mode conf-mode) . hl-line-mode)
  :custom
  ;; Only highlight in selected window
  (hl-line-sticky-flag nil)
  (global-hl-line-sticky-flag nil))
#+END_SRC

* Buffers
Prevent generation of useless lock and backup files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil
      make-backup-files nil)
#+END_SRC

Don't require confirmation when opening a new buffer.
#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer t)
#+END_SRC

Remove visual indicators from non-selected windows
#+BEGIN_SRC emacs-lisp
(setq highlight-nonselected-windows nil)
(setq-default cursor-in-non-selected-windows nil)
#+END_SRC

** Auto save
Disable auto save to avoid unwanted save hooks being triggered. Such as formatting etc.
#+BEGIN_SRC emacs-lisp
(auto-save-visited-mode 0)
(setq save-abbrevs 'silently)
#+END_SRC

** Auto executable scripts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Minibuffer
Enable recursive minibuffers and keep the point out of the minibuffer.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t
      minibuffer-prompt-properties
      '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
#+END_SRC

Give some more room to the minbuffer.
#+BEGIN_SRC emacs-lisp
(setq max-mini-window-height 0.3
      resize-mini-windows 'grow-only)
#+END_SRC

*** No fringes
Don't show fringes in the minibuffer.
#+BEGIN_SRC emacs-lisp
(defun +disable-minibuffer-window-fringes (&optional frame)
  "Disable the window fringes for minibuffer window."
  (let ((target (if frame frame (selected-frame))))
    (with-selected-frame target
      (set-window-fringes (minibuffer-window) 0 0 nil))))
(add-hook 'after-make-frame-functions #'+disable-minibuffer-window-fringes)
(add-hook 'minibuffer-setup-hook #'+disable-minibuffer-window-fringes)
#+END_SRC

*** History
Track minibuffer history
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t
      history-length 500)
#+END_SRC

*** Miniedit
Edit minibuffer in a new temporary buffer by pressing =C-c '=.
#+BEGIN_SRC emacs-lisp
(use-package miniedit
  :general
  (:keymaps
   '(minibuffer-local-map
     minibuffer-local-ns-map
     minibuffer-local-completion-map
     minibuffer-local-must-match-map)
   "C-c '" 'miniedit))
#+END_SRC

** Scrolling
More procedural scrolling.
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil
      hscroll-margin 5
      hscroll-step 5
      scroll-conservatively 101
      scroll-margin 0
      scroll-preserve-screen-position t)

(setq-default scroll-down-aggressively 0.01
              scroll-up-aggressively 0.01)
#+END_SRC

** Packages
*** autorevert
Revert buffers when underlying files change.
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :custom
  (auto-revert-verbose nil))
#+END_SRC

*** default-text-scale
#+BEGIN_SRC emacs-lisp
(use-package default-text-scale
  :general
  ("C-M-=" 'default-text-scale-increase)
  ("C-M--" 'default-text-scale-decrease)
  ("C-M-0" 'default-text-scale-reset))
#+END_SRC

*** eldoc
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :diminish eldoc-mode
  :config
  (global-eldoc-mode 1))
#+END_SRC

*** eldoc-posframe
Display eldoc in a child frame.
#+BEGIN_SRC emacs-lisp
(use-package eldoc-posframe
  :diminish eldoc-posframe-mode
  :custom
  (eldoc-posframe-left-fringe 0)
  (eldoc-posframe-poshandler #'posframe-poshandler-point-bottom-left-corner))
#+END_SRC

*** rainbow-mode
Display colors inline.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :minor
  "-theme\\.el$"
  :hook
  help-mode)
#+END_SRC

*** readable
#+BEGIN_SRC emacs-lisp
(use-package readable
  :diminish readable-mode
  :hook
  ((eww-mode
    markdown-mode
    nov-mode
    org-mode
    rst-mode) . readable-mode))
#+END_SRC

*** relative-buffers
#+BEGIN_SRC emacs-lisp
(use-package relative-buffers
  :demand t
  :custom
  (relative-buffers-project-prefix t)
  :config
  (global-relative-buffers-mode 1))
#+END_SRC

*** spray
#+BEGIN_SRC emacs-lisp
(use-package spray
  :custom
  (spray-height 500)
  (spray-margin-left 2)
  :config
  (setq spray-unsupported-minor-modes
        (append '(beacon-mode centered-window-mode visual-fill-column-mode)
                spray-unsupported-minor-modes)))
#+END_SRC

*** wgrep-ag
Writeable grep buffer with ability to apply the changes to all the files.
#+BEGIN_SRC emacs-lisp
(use-package wgrep-ag
  :custom
  (wgrep-auto-save-buffer t))
#+END_SRC

* Navigation
Allow repeated mark popping. This behavior is similar to Vim's =C-o=. With this
configuration you can press =C-u= and continuously =C-SPC= to jump to previous entries in the
mark ring.
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook
  (dired-mode . auto-revert-mode)
  (dired-mode . hl-line-mode)
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-listing-switches "-al --group-directories-first")
  ;; Always copy/delete recursively
  (dired-recursive-copies  'always)
  (dired-recursive-deletes 'top))
#+END_SRC

*** Editable
#+BEGIN_SRC emacs-lisp
(use-package wdired
  :preface
  (defvar-local +wdired-icons-enabled nil)
  (defun +wdired-before-start-advice ()
    "Execute when switching from `dired' to `wdired'."
    (setq +wdired-icons-enabled (if (bound-and-true-p all-the-icons-dired-mode)
                                    1 0))
    (when (bound-and-true-p all-the-icons-dired-mode)
      (all-the-icons-dired-mode 0)))
  (defun +wdired-after-finish-advice ()
    "Execute when switching from `wdired' to `dired'"
    (when (boundp 'all-the-icons-dired-mode)
      (all-the-icons-dired-mode +wdired-icons-enabled)))
  (advice-add 'wdired-change-to-wdired-mode :before #'+wdired-before-start-advice)
  (advice-add 'wdired-change-to-dired-mode :after #'+wdired-after-finish-advice)
  :general
  (:keymaps
   'dired-mode-map
   "C-c '" 'wdired-change-to-wdired-mode))
#+END_SRC

*** Sidebar
#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :hook
  (dired-sidebar-mode . hide-mode-line-mode)
  (dired-sidebar-mode . hl-line-mode)
  (dired-sidebar-mode . variable-pitch-mode)
  (dired-sidebar-mode . +dired-sidebar-setup)
  :general
  (:prefix
   +leader-key
   "n" 'dired-sidebar-toggle-sidebar)
  :preface
  (defun +dired-sidebar-setup ()
    (setq cursor-type nil)
    (stripe-buffer-mode 0)))
#+END_SRC

*** Subtree
Display subtrees in dired view.
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :custom
  (dired-subtree-use-backgrounds nil)
  (dired-subtree-line-prefix "     "))
#+END_SRC

*** Stripes
Striped dired buffers.
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :hook
  (dired-mode . stripe-buffer-mode))
#+END_SRC

*** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :diminish all-the-icons-dired-mode
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

*** Git
#+BEGIN_SRC emacs-lisp
(use-package dired-git-info
  :general
  (:keymaps
   'dired-mode-map
   ")" 'dired-git-info-mode))
#+END_SRC

** Packages
*** ace-link
Hint mode for links.
#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :general
  (:prefix
   +search-prefix
   "o" 'ace-link)
  (:keymaps
   '(help-mode-map helpful-mode-map)
   "o" 'ace-link-help))
#+END_SRC

*** bibliothek
Management tool for a library of PDFs.
#+BEGIN_SRC emacs-lisp
(use-package bibliothek
  :custom
  (bibliothek-path '("~/books" "~/documents/research/papers"))
  (bibliothek-recursive t)
  :general
  (:prefix
   +launch-prefix
   "b" 'bibliothek))
#+END_SRC

*** bookmark
Keep track of bookmarks
#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :custom
  (bookmark-save-flag 1))
#+END_SRC

*** deadgrep
#+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :general
  (:prefix
   +search-prefix
   "G" 'deadgrep)
  (:keymaps
   'deadgrep-mode-map
   "C-c '" 'deadgrep-edit-mode))
#+END_SRC

*** deft
#+BEGIN_SRC emacs-lisp
(use-package deft
  :custom
  (deft-auto-save-interval 0)
  (deft-directory (expand-file-name "~/org/"))
  (deft-extensions '("org" "md" "rst" "txt" "tex"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  :general
  (:prefix
   +launch-prefix
   "n" 'deft))
#+END_SRC

*** find-file
#+BEGIN_SRC emacs-lisp
(use-package find-file
  :init
  (setq-default ff-quiet-mode t)
  (put 'ff-search-directories 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))

(use-package ff-test
  :demand t)
#+END_SRC

*** goto-last-change
Move point through buffer-undo-list positions.
#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :general
  (:prefix
   +next-prefix
   "l" '(goto-last-change :wk "Change"))
  (:prefix
   +prev-prefix
   "l" '(goto-last-change-reverse :wk "Change")))
#+END_SRC

*** recentf
Keep track of recently opened files.
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer 2
  :custom
  (recentf-exclude
   (list "/tmp/"                        ; Temp-files
         "/dev/shm"                     ; Potential secrets
         "/ssh:"                        ; Files over SSH
         "/TAGS$"                       ; Tag files
         "^/\\.git/.+$"                 ; Git contents
         "\\.?ido\\.last$"
         "\\.revive$"
         "^/var/folders/.+$"
         (concat "^" +cache-dir ".+$")
         (concat "^" +data-dir ".+$")))
  (recentf-filename-handlers '(abbreviate-file-name))
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 300)
  (recentf-auto-cleanup 'never)
  :config
  (quiet! (recentf-mode 1)))
#+END_SRC

*** saveplace
Keep track of last point place to resume editing in the same file.
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :defer 2
  :config
  (save-place-mode 1))
#+END_SRC

** Project
Project interactions. Prefix project buffer files with the project name and relative path.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :demand t
  :diminish projectile-mode
  :custom
  (projectile-enable-caching nil)
  (projectile-file-exists-remote-cache-expire nil)
  (projectile-globally-ignored-file-suffixes
   '(".elc" ".pyc" ".o" ".hi" ".class" ".cache"))
  (projectile-globally-ignored-files
   '("TAGS" "GPATH" "GRTAGS" "GTAGS"))
  (projectile-ignored-projects (list +data-dir))
  (projectile-indexing-method 'alien)
  :general
  (:keymaps
   'projectile-mode-map
   [remap eshell] (general-predicate-dispatch #'eshell
                    :docstring "Creat an interactive Eshell buffer (project aware)"
                    (projectile-project-p) #'projectile-run-eshell)
   [remap term] (general-predicate-dispatch #'term
                  :docstring "Create an interactive terminal buffer (project aware)"
                  (projectile-project-p) #'projectile-run-term))
  (:keymaps
   'projectile-mode-map
   :prefix
   +leader-key
   "p" '(:keymap projectile-command-map :package projectile :wk "project"))
  :init
  (defun +projectile-cache-current-file (orig-fun &rest args)
    "Don't cache ignored files."
    (unless (cl-some (lambda (path)
                       (string-prefix-p buffer-file-name
                                        (expand-file-name path)))
                     (projectile-ignored-directories))
      (apply orig-fun args)))
  (advice-add #'projectile-cache-current-file :around #'+projectile-cache-current-file)
  (cl-pushnew '(setq projectile-project-root (locate-dominating-file buffer-file-name ".dir-locals.el"))
              safe-local-eval-forms
              :test #'equal)
  :config
  (setq projectile-globally-ignored-directories
        (append '("_build"
                  "target" "project/target"
                  "vendor/bundle" "vendor/cache"
                  "elm-stuff" "tests/elm-stuff")
                projectile-globally-ignored-directories))
  (setq projectile-other-file-alist
        (append '(("less" "css")
                  ("styl" "css")
                  ("sass" "css")
                  ("scss" "css")
                  ("css" "scss" "sass" "less" "styl")
                  ("jade" "html")
                  ("pug" "html")
                  ("html" "jade" "pug" "jsx" "tsx"))
                projectile-other-file-alist))
  (setq projectile-project-root-files
        (append '("package.json" "Package.swift" "README.md")
                projectile-project-root-files))

  (projectile-mode 1))
#+END_SRC

Manage project repositories.
#+BEGIN_SRC emacs-lisp
(use-package ivy-ghq
  :defer 2
  :custom
  (ivy-ghq-short-list t)
  :general
  (:keymaps
   'counsel-mode-map
   "C-c P" 'ivy-ghq-open))
#+END_SRC

* Completion
Enable completion with tab
#+BEGIN_SRC emacs-lisp
(setq tab-always-indent t)
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :custom
  (company-show-numbers t)
  (company-backends
   '((company-files
      company-keywords
      company-capf)))
  :hook
  (prog-mode . company-mode)
  :general
  (:keymaps
   'company-mode-map
   "C-?" 'company-complete)
  (:keymaps
   'company-active-map
   ;; No interference with return key
   [return]  'nil
   "RET"     'nil
   "C-e" 'company-complete-selection
   "C-f" 'company-complete-selection
   "C-n" 'company-select-next
   "C-p" 'company-select-previous))
#+END_SRC

** Hippie
Smart expansion completions, excellent for completing lines.
Replace abbrev completion (=M-/=) with hippie expand.

Complete in the following order:
- Try to expand word "dynamically", searching the current buffer.
- Try to expand word "dynamically", searching all other buffers.
- Try to expand word "dynamically", searching the kill ring.
- Try to complete text as a file name, as many characters as unique.
- Try to complete text as a file name.
- Try to expand word before point according to all abbrev tables.
- Try to complete the current line to an entire line in the buffer.
- Try to complete as an Emacs Lisp symbol, as many characters as unique.
- Try to complete word as an Emacs Lisp symbol.
#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :custom
  (hippie-expand-try-functions-list
   '(try-expand-dabbrev-visible
     try-expand-dabbrev
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-expand-line-all-buffers
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))
  :general
  ([remap dabbrev-expand] 'hippie-expand))
#+END_SRC

** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish ivy-mode
  :hook
  (after-init . ivy-mode)
  :custom
  (ivy-hooks-alist '((t . hl-line-mode)))
  (ivy-wrap t)
  (ivy-on-del-error-function #'ignore)
  (ivy-use-virtual-buffers t)
  ;; Allow selecting the prompt as a candidate (e.g for creating a new file)
  (ivy-use-selectable-prompt t)
  (ivy-fixed-height-minibuffer t)
  ;; Highlight whole line
  (ivy-format-function #'ivy-format-function-line)
  ;; Don't use ^ as initial input.
  (ivy-initial-inputs-alist nil)
  :general
  (:keymaps
   'ivy-mode-map
   [remap switch-to-buffer] 'ivy-switch-buffer
   "C-c SPC"                'ivy-resume)
  (:keymaps
   'ivy-mode-map
   :prefix
   +window-prefix
   "v" 'ivy-push-view
   "V" 'ivy-pop-view
   "'" 'ivy-switch-view)
  (:keymaps
   'ivy-occur-grep-mode-map
   "C-c '" 'ivy-wgrep-change-to-wgrep-mode)
  (:keymaps
   'ivy-minibuffer-map
   "C-<return>" 'ivy-immediate-done
   "C-e"        '+ivy-move-end-of-line-or-done
   "C-f"        '+ivy-forward-or-done
   "C-l"        'ivy-alt-done
   "C-u"        'ivy-kill-line
   "C-w"        'ivy-backward-kill-word)
  :preface
  (defun +ivy-move-end-of-line-or-done (arg)
    "Move to end of current line or consider ivy operation done.
   ARG lines can be used."
    (interactive "p")
    (if (eolp)
        (ivy-alt-done)
      (move-end-of-line arg)))
  (defun +ivy-forward-or-done (n)
    "Move point forward or consider ivy operation done.
      N characters can be used."
    (interactive "p")
    (if (eolp)
        (ivy-alt-done)
      (forward-char n)))
  :init
  (setq-default
   dumb-jump-selector             'ivy
   magit-completing-read-function #'ivy-completing-read
   projectile-completion-system   'ivy
   smex-completion-method         'ivy))
#+END_SRC

*** Packages
**** counsel
Replacements for common Emacs commands. =smex= is used by =counsel-M-x= for sorting.
Tips:
- =counsel-rg= can be used with =C-u= to search in a specific directory.
#+BEGIN_SRC emacs-lisp
(use-package smex
  :custom
  (smex-auto-update nil))

(use-package counsel
  :diminish counsel-mode
  :hook (ivy-mode . counsel-mode)
  :custom
  (counsel-find-file-ignore-regexp
   "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")
  (counsel-grep-base-command
   "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
  (counsel-mode-override-describe-bindings t)
  :general
  ;; Use counsel/swiper for search
  ("C-s" 'swiper-isearch)
  ("C-x /" 'counsel-abbrev)
  (:keymaps
   'counsel-mode-map
   "C-c p" 'counsel-git
   "C-c r" 'counsel-recentf)
  (:keymaps
   'counsel-mode-map
   :prefix +search-prefix
   "g" 'counsel-rg
   "i" 'counsel-imenu)
  (:keymaps
   'counsel-ag-map
   "C-SPC" 'ivy-call-and-recenter)
  :config
  (setq ivy-initial-inputs-alist nil)

  (defun counsel-abbrev (abbrev-name)
    "Insert abbreviation matching ABBREV-NAME."
    (interactive
     (list
      (ivy-completing-read
       "Insert abbrev: "
       (cl-loop for table in (abbrev--active-tables)
                unless (abbrev-table-empty-p table)
                append (append (delete 0 table) ())))))
    (progn
      (dolist (table (abbrev--active-tables))
        (when (abbrev-symbol abbrev-name table)
          (abbrev-insert (abbrev-symbol abbrev-name table))))))

  (defun counsel-git-expanded-cands ()
    (let ((root (counsel--git-root)))
      (when root
        (mapcar
         (lambda (f) (expand-file-name f root))
         (counsel-git-cands)))))

  (ivy-set-sources
   'counsel-recentf
   '((original-source)
     (counsel-git-expanded-cands))))
#+END_SRC

**** swiper
I-search replacement with overview
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :general
  (:keymaps
   'swiper-isearch-map
   "M-n" 'ivy-next-history-element))
#+END_SRC

**** flyspell-correct-ivy
#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :general
  (:prefix
   +next-prefix
   "S" '(flyspell-correct-word-generic :wk "Spell fix"))
  (:prefix
   +prev-prefix
   "S" '(flyspell-correct-previous-word-generic :wk "Spell fix")))
#+END_SRC

**** imenu-anywhere
Jump to document locations in current buffer
#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :general
  (:keymaps
   'ivy-mode-map
   [remap imenu-anywhere] 'ivy-imenu-anywhere)
  (:keymaps
   'ivy-mode-map
   :prefix +search-prefix
   "I" 'ivy-imenu-anywhere))
#+END_SRC

**** ivy-xref
Support =xref= lookups.
#+BEGIN_SRC emacs-lisp
(use-package ivy-xref
  :init
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

**** ivy-yasnippet
Snippets with preview.
#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  :general
  ([remap yas-insert-snippet] 'ivy-yasnippet)
  (:keymaps
   'yas-minor-mode-map
   :prefix
   +leader-key
   "y" 'ivy-yasnippet))
#+END_SRC

**** counsel-tramp
Navigate tramp files.
#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp
  :general
  (:prefix
   +leader-key
   "t" 'counsel-tramp))
#+END_SRC

*** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :defer 1
  :after
  (ivy counsel)
  :config
  (all-the-icons-ivy-setup))
#+END_SRC

* Development
Reduce scroll margin.
#+BEGIN_SRC emacs-lisp
(defun +prog-scroll-margin-setup ()
  "Setup `scroll-margin' for `prog-mode'."
  (setq-local scroll-margin 3))
(add-hook 'prog-mode-hook #'+prog-scroll-margin-setup)
#+END_SRC

** Compilation
Kill compilation process before stating another and save all buffers on =compile.=
#+BEGIN_SRC emacs-lisp
(use-package compile
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-scroll-output t)
  :general
  (:keymaps
   'global
   :prefix
   +local-leader-key
   "c" 'recompile
   "C" 'compile)
  :init
  (make-variable-buffer-local 'compile-command)
  (put 'compile-command 'safe-local-variable 'stringp))
#+END_SRC

*** ANSI escape
#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun +colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region compilation-filter-start (point))))
(add-hook 'compilation-filter-hook #'+colorize-compilation)
#+END_SRC

** Containers
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :general
  (:prefix
   +leader-key
   "d" 'docker
   "c" 'docker-compose))
#+END_SRC

**** Files
Support for Docker related files.
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode)
(use-package docker-compose-mode)
#+END_SRC

**** Tramp
#+BEGIN_SRC emacs-lisp
(use-package docker-tramp
  :defer 2
  :custom
  (docker-tramp-use-names t))
#+END_SRC

*** Kubernetes
#+BEGIN_SRC emacs-lisp
(use-package kubernetes)
#+END_SRC

**** Tramp
#+BEGIN_SRC emacs-lisp
(use-package kubernetes-tramp :defer 2)
#+END_SRC

** Coverage
#+BEGIN_SRC emacs-lisp
(use-package coverlay
  :diminish coverlay-minor-mode
  :custom
  (coverlay:mark-tested-lines nil)
  :init
  (defun +coverlay-mode-enable ()
    "Turn on `coverlay-mode'."
    (coverlay-minor-mode 1)
    (when (and (buffer-file-name) (not (bound-and-true-p coverlay--loaded-filepath)))
      (let* ((coverage-file (concat
                             (locate-dominating-file (file-name-directory (buffer-file-name)) "coverage")
                             "coverage"
                             "/lcov.info")))
        (when (file-exists-p coverage-file)
          (coverlay-watch-file coverage-file))))))
#+END_SRC

** Docs
*** DevDocs
Lookup documentation via DevDocs.
#+BEGIN_SRC emacs-lisp
(use-package devdocs
  :general
  ("M-g K" 'devdocs-search))
#+END_SRC

** Eval
*** quickrun
#+BEGIN_SRC emacs-lisp
(use-package quickrun
  :hook
  (quickrun--mode . display-ctrl-M-as-newline)
  :general
  (:prefix
   +local-leader-key
   "q" 'quickrun
   "Q" 'quickrun-autorun-mode))
#+END_SRC

** Folding
Code folding.
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :diminish hs-minor-mode
  :hook (prog-mode . hs-minor-mode)
  :custom
  (hs-hide-comments-when-hiding-all nil)
  :general
  (:prefix
   (concat +leader-key " " "z")
   ""      '(:ignore t :wk "hide")
   "c"     'hs-hide-block
   "o"     'hs-show-block
   "C"     'hs-hide-all
   "O"     'hs-show-all
   "l"     'hs-hide-level
   "z"     'hs-toggle-hiding
   "<tab>" 'hs-toggle-hiding)
  :init
  (defun +hs-fold-overlay-ellipsis (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put
       ov 'display (propertize " … " 'face 'font-lock-comment-face))))

  (setq hs-allow-nesting t
        hs-set-up-overlay #'+hs-fold-overlay-ellipsis))
#+END_SRC

** Formatting
*** aggressive-indent
Automatic indentation as you type. It is a bit more robust than =electric-indent-mode=, but
perhaps I should look into using that for those modes that are not compatible with
=aggressive-indent-mode=.
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :diminish aggressive-indent-mode
  :hook
  ((emacs-lisp-mode
    lisp-mode
    nix-mode) . aggressive-indent-mode))
#+END_SRC

*** apheleia
Reformat buffer without moving point.
#+BEGIN_SRC emacs-lisp
(use-package apheleia
  :defer 2
  :init
  (put 'apheleia-formatter 'safe-local-variable 'symbolp)
  :config
  (progn ;; JavaScript/TypeScript
    (cl-pushnew '(eslint . (npx "eslint_d" "--fix-to-stdout" "--stdin" "--stdin-filename" file)) apheleia-formatters :test #'equal))
  (progn ;; Terraform
    (cl-pushnew '(terraform . ("terraform" "fmt" "-")) apheleia-formatters :test #'equal)
    (cl-pushnew '(terraform-mode . terraform) apheleia-mode-alist :test #'equal))
  (apheleia-global-mode 1))
#+END_SRC

*** reformatter
Custom formatters.
#+BEGIN_SRC emacs-lisp
(use-package reformatter
  :demand t
  :config
  (reformatter-define prettier-typescript-format
    :program "prettier"
    :args '("--stdin" "--stdin-filepath=f.ts"))
  (reformatter-define javascript-format
    :program "eslint_d"
    :args '("--stdin" "--stdin-filename=f.js" "--fix-to-stdout"))
  (reformatter-define typescript-format
    :program "eslint_d"
    :args '("--stdin"  "--stdin-filename=f.ts" "--fix-to-stdout")))
#+END_SRC

** Jump to definition
Jump to definition is really useful and I prefer doing so without TAGS which is pretty
much the default for most modes. I am using the excellent package =dumb-jump= to jump via
grep tools e.g. (=grep=, =rx=, =ag=)

Don't ask about keeping current list of tags tables.
#+BEGIN_SRC emacs-lisp
(use-package etags
  :custom
  (tags-add-tables nil))
#+END_SRC

*** dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :custom
  (dumb-jump-default-project user-emacs-directory)
  :general
  (:prefix
   +nav-prefix
   "i" 'dumb-jump-go-prompt
   "o" 'dumb-jump-go-other-window
   "x" 'dumb-jump-go-prefer-external
   "z" 'dumb-jump-go-prefer-external-other-window))
#+END_SRC

*** smart-jump
Some modes actually have some good backends, so configure this with =smart-jump= which has
nice defaults and also adds configuring completion with a fallback to =dumb-jump=.
#+BEGIN_SRC emacs-lisp
(use-package smart-jump
  :defer 2
  :custom
  (smart-jump-find-references-fallback-function #'+smart-jump-find-references-with-counsel-rg)
  (smart-jump-default-mode-list
   '(clojure-mode
     eglot
     elisp-mode
     elixir-mode
     elm-mode
     erlang-mode
     go-mode
     lisp-mode
     lua-mode
     python))
  :general
  ("M-." 'smart-jump-go)
  ("M-," 'smart-jump-back)
  ("M-?" 'smart-jump-references)
  (:prefix
   +nav-prefix
   "j" 'smart-jump-go
   "r" 'smart-jump-references)
  :preface
  (defun +smart-jump-find-references-with-counsel-rg ()
    "Use `rg' and `counsel' to find references."
    (interactive)
    (if (fboundp 'counsel-rg)
        (counsel-rg
         (cond ((use-region-p)
                (buffer-substring-no-properties (region-beginning)
                                                (region-end)))
               ((symbol-at-point)
                (substring-no-properties
                 (symbol-name (symbol-at-point))))))
      (message "Install swiper to use `+smart-jump-simple-find-references-with-counsel-rg'.")))
  :config
  (smart-jump-setup-default-registers))
#+END_SRC

** Refactor
Refactoring commands for various languages.
#+BEGIN_SRC emacs-lisp
(use-package emr
  :general
  (:keymaps
   'prog-mode-map
   "M-<return>" 'emr-show-refactor-menu))
#+END_SRC

** REPL
*** repl-toggle
#+BEGIN_SRC emacs-lisp
(use-package repl-toggle
  :custom
  (rtog/goto-buffer-fun 'pop-to-buffer)
  (rtog/mode-repl-alist '((emacs-lisp-mode . ielm)
                          (clojure-mode . clojure-repl)
                          (elm-mode . elm-repl-load)
                          (go-mode . gorepl-run)
                          (js-mode . js-repl)
                          (lisp-mode . slime)
                          (lua-mode . lua-repl)
                          (nix-mode . nix-repl)
                          (racket-mode . racket-repl)
                          (typescript-mode . run-ts)))
  :general
  (:keymaps
   'prog-mode-map
   :prefix +local-leader-key
   "r" 'rtog/toggle-repl)
  :preface
  (defun clojure-repl ()
    "Open a Clojure REPL."
    (interactive)
    (pop-to-buffer (cider-current-repl nil 'ensure)))

  (defun js-repl ()
    "Open a JavaScript REPL."
    (interactive)
    (if (indium-client-process-live-p) (indium-switch-to-repl-buffer) (nodejs-repl)))

  (defun lua-repl ()
    "Open a Lua REPL."
    (interactive)
    (pop-to-buffer (process-buffer (lua-get-create-process)))))
#+END_SRC

*** Persistent history in comint
#+BEGIN_SRC emacs-lisp
(defun +comint-history-write-on-exit (process event)
  "Write `comint' history on exit.
Receives PROCESS and EVENT."
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun +comint-history-enable ()
  "Enable `comint' history."
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (expand-file-name
             (format "comint-%s-history" (process-name process))
             +cache-dir))
      (comint-read-input-ring)
      (set-process-sentinel process #'+comint-history-write-on-exit))))
#+END_SRC

** Syntax checker
Silence next/previous error, by default it produces a message every time.
#+BEGIN_SRC emacs-lisp
(advice-add #'next-error :around #'quiet-function-advice)
(advice-add #'previous-error :around #'quiet-function-advice)
#+END_SRC

*** flymake
Connect flymake to =next-error-function= and add some navigation bindings. Disable the
legacy diagnostic functions as some of them have bugs and cause instability (mainly the
Haskell one).
#+BEGIN_SRC emacs-lisp
(use-package flymake
  :hook
  (flymake-mode . +flymake-setup-next-error-function)
  :custom
  (help-at-pt-timer-delay 0.1)
  (help-at-pt-display-when-idle '(flymake-diagnostic))
  (flymake-proc-ignored-file-name-regexps '("\\.l?hs\\'"))
  :general
  (:keymaps
   'flymake-mode-map
   :prefix
   +local-leader-key
   "!" 'flymake-show-diagnostics-buffer)
  (:keymaps
   'flymake-mode-map
   :prefix +next-prefix
   "E" 'flymake-goto-next-error)
  (:keymaps
   'flymake-mode-map
   :prefix +prev-prefix
   "E" 'flymake-goto-prev-error)
  (:keymaps
   'flymake-diagnostics-buffer-mode-map
   "n" '+flymake-diagnostics-next-error
   "p" '+flymake-diagnostics-prev-error
   "j" '+flymake-diagnostics-next-error
   "k" '+flymake-diagnostics-prev-error
   "RET" 'flymake-goto-diagnostic
   "TAB" 'flymake-show-diagnostic)
  :preface
  (defun +flymake-setup-next-error-function ()
    (setq next-error-function 'flymake-goto-next-error))

  (defun +flymake-diagnostics-next-error ()
    (interactive)
    (forward-line)
    (when (eobp) (forward-line -1))
    (flymake-show-diagnostic (point)))

  (defun +flymake-diagnostics-prev-error ()
    (interactive)
    (forward-line -1)
    (flymake-show-diagnostic (point)))
  :init
  (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
#+END_SRC

**** Diagnostics at point
#+BEGIN_SRC emacs-lisp
(use-package flymake-diagnostic-at-point
  :hook
  (flymake-mode . flymake-diagnostic-at-point-mode)
  :preface
  (defun flymake-diagnostic-at-point-quick-peek (text)
    "Display the flymake diagnostic TEXT with `quick-peek'`."
    (quick-peek-show (concat flymake-diagnostic-at-point-error-prefix text)))
  :custom
  (flymake-diagnostic-at-point-error-prefix nil))
#+END_SRC

** Version control
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t
      vc-make-backup-files nil)
#+END_SRC

*** ediff
- Split horizontally
- Use existing frame instead of creating a new one
- Add a third resolution option, copy both A and B to C
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :hook
  (ediff-quit . winner-undo)
  (ediff-keymap-setup . +ediff-keys-setup)
  :custom
  (ediff-diff-options "-w")
  (ediff-merge-split-window-function #'split-window-horizontally)
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  :preface
  (defun ediff-copy-both-to-C ()
    "Copy change from both A and B to C."
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

  (defun +ediff-keys-setup ()
    "Setup keybindings for `ediff-mode'."
    (general-define-key
     :keymaps 'ediff-mode-map
     "d" '(ediff-copy-both-to-C      :wk "Copy both to C")
     "j" '(ediff-next-difference     :wk "Next difference")
     "k" '(ediff-previous-difference :wk "Previous difference"))))
#+END_SRC

*** diff-hl
Diff indicators in fringe
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 2
  :hook
  (dired-mode         . diff-hl-dired-mode)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :init
  (autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" nil t)
  (autoload 'diff-hl-dired-mode "diff-hl-dired" nil t)
  :config
  (global-diff-hl-mode 1)
  (diff-hl-flydiff-mode 1))
#+END_SRC

*** magit
Enhanced git related views and commands.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer 2
  :hook
  (git-commit-mode . +git-commit-set-fill-column)
  :custom
  (magit-log-buffer-file-locked t)
  (magit-refs-show-commit-count 'all)
  (magit-save-repository-buffers 'dontask)
  (vc-msg-git-show-commit-function 'magit-show-commit)
  :preface
  (defun +git-commit-set-fill-column ()
    "Set `fill-column' for git commit."
    (setq fill-column 72))
  :config
  ;; Unset pager as it is not supported properly inside emacs.
  (setenv "GIT_PAGER" "")
  (global-magit-file-mode 1))
#+END_SRC

*** vc-msg
Popup commit message for current line
#+BEGIN_SRC emacs-lisp
(use-package vc-msg
  :general
  ("C-x v p" 'vc-msg-show))
#+END_SRC

** Packages
*** direnv
Project-specific environment variables via =direnv=.
#+BEGIN_SRC emacs-lisp
(use-package direnv
  :demand t
  :hook
  (before-hack-local-variables . direnv-update-environment)
  :custom
  (direnv-always-show-summary nil)
  :config
  (direnv-mode 1))
#+END_SRC

*** editorconfig
Use [[https://editorconfig.org/][EditorConfig]] to maintain the coding styles used across different projects.
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :defer 1
  :diminish editorconfig-mode
  :custom
  (editorconfig-trim-whitespaces-mode 'ws-butler-mode)
  :config
  (editorconfig-mode 1))
#+END_SRC

*** eglot
Generic Language Server Protocol integration via =eglot=.
#+BEGIN_SRC emacs-lisp
(use-package eglot
  :defer 3
  :hook
  ((haskell-mode
    java-mode
    ruby-mode
    rustic-mode
    typescript-mode) . eglot-ensure)
  (js-mode . +eglot-ensure-unless-json-mode)
  :preface
  (defun +eglot-ensure-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (eglot-ensure)))
  :custom
  (eglot-sync-connect nil)
  :general
  (:keymaps
   'eglot-mode-map
   "M-g k" 'eglot-help-at-point)
  (:keymaps
   'eglot-mode-map
   :prefix +local-leader-key
   "e" '(:ignore t :wk "eglot")
   "ea" 'eglot-code-actions
   "ef" 'eglot-format
   "eh" 'eglot-help-at-point
   "er" 'eglot-rename)
  :config
  (cl-pushnew '(typescript-mode . ("javascript-typescript-stdio"))
              eglot-server-programs
              :test #'equal))
#+END_SRC

*** helm-make
Execute make tasks.
#+BEGIN_SRC emacs-lisp
(use-package helm-make
  :custom
  (helm-make-completion-method 'ivy)
  :general
  (:prefix
   +leader-key
   "m" (general-predicate-dispatch #'helm-make
         :docstring "Run make task (project aware)"
         (projectile-project-p) #'helm-make-projectile)))
#+END_SRC

*** hl-todo
Highlight *TODO* inside comments and strings.
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook
  (prog-mode . hl-todo-mode))
#+END_SRC

*** idle-highlight
Highlight symbol at point on idle.
#+BEGIN_SRC emacs-lisp
(use-package idle-highlight-mode
  :hook prog-mode)
#+END_SRC

*** imenu-list
Document locations in a sidebar.
#+BEGIN_SRC emacs-lisp
(use-package imenu-list
  :general
  (:prefix
   +leader-key
   "i" 'imenu-list-smart-toggle))
#+END_SRC

*** source-peek
Peek definition (Display the function source inline).
#+BEGIN_SRC emacs-lisp
(use-package source-peek
  :general
  (:prefix
   +nav-prefix
   "SPC" 'source-peek))
#+END_SRC

*** ws-butler
Delete trailing white-space before save, but *only* for edited lines.
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :diminish ws-butler-mode
  :custom
  (ws-butler-convert-leading-tabs-or-spaces t))
#+END_SRC

** Appearance
*** Highlight delimiters
Visually separate delimiter pairs.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :custom
  (rainbow-delimiters-max-face-count 3)
  :hook
  ((clojure-mode
    emacs-lisp-mode
    ielm-mode
    lisp-mode
    racket-mode) . rainbow-delimiters-mode))
#+END_SRC

*** Highlight identifiers
Highlight source code identifiers based on their name.
#+BEGIN_SRC emacs-lisp
(use-package color-identifiers-mode
  :defer 2
  :diminish color-identifiers-mode
  :config
  (cl-pushnew '(js-mode . ("[^.][[:space:]]*"
                            "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                            (nil font-lock-variable-name-face js2-function-param)
                            "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (cl-pushnew '(rjsx-mode . ("[^.][[:space:]]*"
                            "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                            (nil font-lock-variable-name-face js2-function-param)
                            "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (cl-pushnew '(typescript-mode . ("[^.][[:space:]]*"
                                   "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                                   (nil font-lock-variable-name-face)
                                   "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (global-color-identifiers-mode 1))

(use-package rainbow-identifiers
  :diminish rainbow-identifiers-mode
  :custom
  (rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face))
#+END_SRC

*** Highlight numbers
For modes that don't adequately highlight numbers.
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :hook
  (prog-mode . highlight-numbers-mode))
#+END_SRC

*** Prettify symbols
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(prettify-symbols-unprettify-at-point t))

(defun +prog-prettify-symbols-setup ()
  "Add generic programming symbols."
  (dolist (symbol '(("&&" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∧))
                    ("||" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∨))
                    (":=" . (?: (Br . Bc) ?= (Br . Bc) ?=))
                    ("==" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                    ("===" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                    ("!==" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                    (">="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥))
                    ("<="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤))
                    ("/=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                    ("!=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                    ("<-" . (?< (Br . Bc) ?- (Br . Bc) ?-))
                    ("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))
                    ("<==" . (?< (Br . Bc) ?= (Br . Bc) ?=))
                    ("==>" . (?= (Br . Bc) ?= (Br . Bc) ?>))
                    ("lambda" . ?λ)))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'prog-mode-hook #'+prog-prettify-symbols-setup)

(global-prettify-symbols-mode 1)
#+END_SRC

* Major modes
** elisp
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'flymake-mode)

(general-define-key
 :keymaps 'emacs-lisp-mode-map
 :prefix +local-leader-key
 "c" 'emacs-lisp-byte-compile
 "C" 'emacs-lisp-byte-compile-and-load
 "t" 'ert)

(custom-set-variables
 '(ad-redefinition-action 'accept)
 '(apropos-do-all t)
 '(enable-local-eval 'maybe)
 '(enable-local-variables :safe))
#+END_SRC

Specific safe local code can be specified via:
- =safe-local-variable-values=
- =safe-local-eval-forms=
- =safe-local-eval-function=

*** ielm
Persist ielm history.
#+BEGIN_SRC emacs-lisp
(defvar +ielm-comint-input-ring nil)
(with-eval-after-load 'savehist
  (cl-pushnew '+ielm-comint-input-ring savehist-additional-variables :test #'equal))

(defun +ielm-set-comint-input-ring ()
  "Restore `ielm' history."
  (setq-local comint-input-ring-size 200)
  (add-hook 'kill-buffer-hook #'+ielm-save-comint-input-ring nil t)
  (when +ielm-comint-input-ring
    (setq comint-input-ring +ielm-comint-input-ring)))

(defun +ielm-save-comint-input-ring ()
  "Save `ielm' history."
  (setq +ielm-comint-input-ring comint-input-ring))

(add-hook 'ielm-mode-hook #'+ielm-set-comint-input-ring)
#+END_SRC

*** eval-expression
Highlight parenthesis.
#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'show-paren-mode)
#+END_SRC

*** Packages
**** auto-compile
Auto-compile Elisp files.
#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :hook
  (emacs-lisp-mode . auto-compile-on-load-mode)
  (emacs-lisp-mode . auto-compile-on-save-mode)
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-use-mode-line nil))
#+END_SRC

**** eros
Evaluation results in overlay.
#+BEGIN_SRC emacs-lisp
(use-package eros
  :hook
  (emacs-lisp-mode . eros-mode))
#+END_SRC

**** esup
Emacs Start Up Profiler.
#+BEGIN_SRC emacs-lisp
(use-package esup)
#+END_SRC

**** helpful
Better =*help*= buffer
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :hook
  (helpful-mode . turn-off-truncate-lines)
  :general
  (:keymaps
   'emacs-lisp-mode-map
   :prefix +nav-prefix
   "h" 'helpful-at-point)
  (:keymaps
   'help-map
   "C" 'helpful-command
   "f" 'helpful-function
   "F" 'helpful-callable
   "k" 'helpful-key
   "M" 'helpful-macro
   "v" 'helpful-variable)
  (:keymaps
   'helpful-mode-map
   "[[" 'backward-button
   "]]" 'forward-button))
#+END_SRC

**** highlight-quoted
#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

**** package-lint-flymake
#+BEGIN_SRC emacs-lisp
(use-package package-lint-flymake
  :hook
  (emacs-lisp-mode . package-lint-setup-flymake))
#+END_SRC

**** suggest
Discover functions.
#+BEGIN_SRC emacs-lisp
(use-package suggest
  :general
  (:keymaps
   'emacs-lisp-mode-map
   :prefix +local-leader-key
   "s" '+suggest-popup)
  :preface
  (defun +suggest-popup ()
    "Open suggest as a popup."
    (interactive)
    (let* ((window         (selected-window))
           (dedicated-flag (window-dedicated-p window)))
      (set-window-dedicated-p window t)
      (suggest)
      (set-window-dedicated-p window dedicated-flag))))
#+END_SRC

*** Appearance
**** Package prefixes
Shorten package prefixes.
#+BEGIN_SRC emacs-lisp
(use-package nameless
  :diminish nameless-mode
  :hook
  (emacs-lisp-mode . nameless-mode))
#+END_SRC

**** Prettify symbols
#+BEGIN_SRC emacs-lisp
(defun +emacs-lisp-prettify-symbols-setup ()
  "Prettify `emacs-lisp-mode' specific symbols."
  (dolist (symbol '(("defun"    . ?ƒ)
                    ("defmacro" . ?μ)
                    ("defvar"   . ?ν)
                    ("defconst" . "ν_")))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'emacs-lisp-mode-hook #'+emacs-lisp-prettify-symbols-setup)
#+END_SRC

**** Regular expression escapes
Improve readability of escape characters in regular expressions.
#+BEGIN_SRC emacs-lisp
(use-package easy-escape
  :diminish easy-escape-minor-mode
  :hook
  (emacs-lisp-mode . easy-escape-minor-mode))
#+END_SRC

** erc
#+BEGIN_SRC emacs-lisp
(use-package erc
  :hook
  (erc-mode . +erc-line-setup)
  (erc-mode . +erc-parens-setup)
  :custom
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-prompt-for-password nil)
  :preface
  (defun +erc-line-setup ()
    "Line configuration for `erc-mode'."
    (visual-line-mode 0)
    (turn-off-truncate-lines))

  (defun +erc-parens-setup ()
    "Parenthesis configuration for `erc-mode'."
    (smartparens-strict-mode 0)
    (smartparens-mode 1)))
#+END_SRC

** eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :hook
  (eshell-mode . abbrev-mode)
  (eshell-mode . +eshell-define-keys)
  (eshell-mode . +eshell-set-visual-commands)
  :custom
  (eshell-buffer-maximum-lines 20000)
  (eshell-history-size 1000)
  (eshell-hist-ignoredups t)
  (eshell-error-if-no-glob t)
  (eshell-destroy-buffer-when-process-dies t)
  :general
  (:prefix
   +launch-prefix
   "t" 'eshell)
  :preface
  (defvar eshell-visual-commands)
  (defun +eshell-define-keys ()
    (general-define-key
     :keymaps 'eshell-mode-map
     "RET" '+eshell-expand-abbrev-and-send-input
     "<tab>" 'completion-at-point
     "C-r" 'counsel-esh-history))

  (defun +eshell-set-visual-commands ()
    (setq eshell-visual-commands
          (append
           '("fish" "ghcid" "jshell" "most" "ssh" "tail" "tsun" "watch")
           eshell-visual-commands)))
  :init
  (autoload 'eshell-smart-initialize "em-smart"))
#+END_SRC

*** Abbreviations
Fish-like abbreviations that expand on space or enter.
#+BEGIN_SRC emacs-lisp
(defun +eshell-expand-abbrev-and-send-input ()
  "Expand abbreviation and send input to `eshell'."
  (interactive)
  (expand-abbrev)
  (call-interactively #'eshell-send-input))

(defun +eshell-abbrev-expand-p ()
  "Return t if abbreviation should be expanded.
Expansion should happen when abbreviation is at the beginning of
the line or after an eshell operator."
  (let* ((end (point-marker))
         (begin (save-excursion (eshell-bol) (point)))
         (args (catch 'eshell-incomplete (eshell-parse-arguments begin end))))
    (or (= 1 (length args))
        (let ((last-two-args (last args 2)))
          (and (consp (car last-two-args))
               (eq (caar last-two-args)
                   'eshell-operator))))))

(define-abbrev-table 'eshell-mode-abbrev-table
  '(("base64" "base64 -w0")
    ("d" "docker")
    ("dim" "docker images")
    ("dp" "docker ps")
    ("dc" "docker-compose")
    ("dcl" "docker-compose logs")
    ("e" "find-file-other-window")
    ("E" "dired")
    ("gd" "magit-diff-unstaged")
    ("gds" "magit-diff-staged")
    ("gs" "magit-status")
    ("time" "time -p")
    ("tree" "tree -a")
    ("week" "date '+%V'"))
  :enable-function #'+eshell-abbrev-expand-p)
#+END_SRC

*** Packages
**** eshell-fringe-status
Command execution status indicator in the fringe.
#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :hook
  (eshell-mode . eshell-fringe-status-mode))
#+END_SRC

**** esh-autosuggest
Autosuggestions from history similar to fish.
#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook
  (eshell-mode . esh-autosuggest-mode)
  :general
  (:keymaps
   'esh-autosuggest-active-map
   "C-e" 'company-complete-selection))
#+END_SRC

**** fish-completion
Populate auto-completions from fish.
#+BEGIN_SRC emacs-lisp
(use-package fish-completion
  :hook
  (eshell-mode . fish-completion-mode))
#+END_SRC

** org
#+BEGIN_SRC emacs-lisp
(use-package org-plus-contrib
  :hook
  (org-mode . auto-fill-mode)
  :minor
  ("init\\.org$" . auto-tangle-mode)
  :custom
  (org-agenda-files '("~/org"))
  (org-confirm-babel-evaluate nil)
  (org-babel-load-languages
   '((emacs-lisp . t)
     (clojure    . t)
     (js         . t)
     (plantuml   . t)
     (shell      . t)))
  (org-edit-src-content-indentation 0)
  (org-log-done 'time)
  (org-plantuml-exec-mode 'plantuml)
  (org-startup-folded nil)
  (org-special-ctrl-a/e t)
  (org-src-preserve-indentation nil)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-tag-alist
   '(("@work"  . ?w)
     ("@home"  . ?h)
     ("laptop" . ?l)))
  :defines org-babel-load-languages
  :general
  (:keymaps
   'org-mode-map
   "C-'" 'nil
   "C-," 'nil)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   org-babel-load-languages))
#+END_SRC

*** Packages
**** org-babel-eval-in-repl
Evaluation of source code blocks in REPL.
#+BEGIN_SRC emacs-lisp
(use-package org-babel-eval-in-repl
  :general
  (:keymaps
   'org-mode-map
   "C-<return>" '+org-ctrl-return
   "M-<return>" '+org-meta-return)
  :preface
  (defun +org-ctrl-return ()
    "Run `ober-eval-in-repl' if in source code block and `org-insert-heading-respect-content' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-in-repl)
      (call-interactively #'org-insert-heading-respect-content)))
  (defun +org-meta-return ()
    "Run `ober-eval-block-in-repl' if in source code block or example block and `org-meta-return' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-block-in-repl)
      (call-interactively #'org-meta-return))))
#+END_SRC

**** org-cliplink
Paste links from clipboard and automatically fetch title.
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :general
  (:keymaps
   'org-mode-map
   :prefix +local-leader-key
   "l" 'org-cliplink))
#+END_SRC

**** org-noter
Annotate documents with =org-mode=.
#+BEGIN_SRC emacs-lisp
(use-package org-noter)
#+END_SRC

**** org-preview-html
Preview org-file in an =eww= buffer.
#+BEGIN_SRC emacs-lisp
(use-package org-preview-html)
#+END_SRC

**** org-radiobutton
Support for radiobuttons.
#+BEGIN_SRC emacs-lisp
(use-package org-radiobutton
  :hook
  (org-mode . org-radiobutton-mode))
#+END_SRC

**** org-tree-slide
Presentation mode.
#+BEGIN_SRC emacs-lisp
(use-package org-tree-slide
  :hook
  (org-tree-slide-mode . hide-mode-line-mode)
  :custom
  (org-tree-slide-header nil)
  (org-tree-slide-slide-in-effect nil)
  :general
  (:keymaps
   'org-mode-map
   :prefix +local-leader-key
   "p" 'org-tree-slide-mode))
#+END_SRC

**** ob-http
#+BEGIN_SRC emacs-lisp
(use-package ob-http
  :init
  (cl-pushnew '(http . t) org-babel-load-languages :test #'equal))
#+END_SRC

*** Appearance
This sections makes =org-mode= look more beautiful and appealing.

#+BEGIN_SRC emacs-lisp
(use-package org-plus-contrib
  :hook
  (org-babel-after-execute . org-redisplay-inline-images)
  (org-mode . +org-cursor-setup)
  (org-mode . +org-prettify-syntax-setup)
  :custom
  (org-fontify-quote-and-verse-blocks t)
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
  (org-src-fontify-natively t)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  :preface
  (defun +org-cursor-setup ()
    "Setup bar cursor for `org-mode'."
    (setq cursor-type 'bar))
  (defun +org-prettify-syntax-setup ()
    "Prettify syntax with symbols."
    (dolist (symbol '(("#+TITLE:"    . ?⋮)
                      ("#+begin_src" . ?λ)
                      ("#+BEGIN_SRC" . ?λ)
                      ("#+end_src" . ?≋)
                      ("#+END_SRC" . ?≋)
                      ("#+begin_quote" . ?“)
                      ("#+BEGIN_QUOTE" . ?“)
                      ("#+end_quote" . ?”)
                      ("#+END_QUOTE" . ?”)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(use-package org-variable-pitch
  :diminish org-variable-pitch-minor-mode
  :hook
  (org-mode . org-variable-pitch-minor-mode)
  :custom
  (org-variable-pitch-fixed-font +fixed-pitch-font)
  (org-variable-pitch-fontify-headline-prefix t)
  :init
  (require 'org-indent))
#+END_SRC

**** Headings
#+BEGIN_SRC emacs-lisp
(use-package org-plus-contrib
  :custom
  (org-ellipsis "  ")
  (org-fontify-whole-heading-line t)
  (org-fontify-todo-headline t)
  (org-fontify-done-headline t))
#+END_SRC

***** Bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :hook
  (org-mode . org-bullets-mode)
 :custom
 (org-bullets-bullet-list '(" "))
 ;; Use default font face (also size)
 (org-bullets-face-name 'org-variable-pitch-face))
#+END_SRC

**** Bullet lists
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ +\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
   ("^ *[-*+] \\[\\(X\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

**** Task lists
Use symbols to represent task state.
#+BEGIN_SRC emacs-lisp
(defun +org-prettify-task-symbols-setup ()
  "Prettify task list symbols."
  (dolist (symbol '(("TODO"     . ?⚑)
                    ("DOING"    . ?⚐)
                    ("CANCELED" . ?✘)
                    ("DONE"     . ?✔)))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'org-mode-hook #'+org-prettify-task-symbols-setup)
#+END_SRC

**** Breadcrumbs
Remove style from heading breadcrumbs.
#+BEGIN_SRC emacs-lisp
(defun +org-eldoc-get-breadcrumb-no-properties (string)
  "Remove properties from STRING."
  (when string (substring-no-properties string)))
(advice-add 'org-eldoc-get-breadcrumb :filter-return #'+org-eldoc-get-breadcrumb-no-properties)
#+END_SRC

**** Tables
#+BEGIN_SRC emacs-lisp
(use-package org-pretty-table
  :hook
  (org-mode . org-pretty-table-mode))
#+END_SRC

*** Export
**** LaTeX
Disable link colors.
#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :custom
  (org-latex-hyperref-template
   (mapconcat
    'identity
    '("\\hypersetup{"
      "pdfauthor={%a},"
      "pdftitle={%t},"
      "pdfkeywords={%k},"
      "pdfsubject={%d},"
      "pdfcreator={%c},"
      "pdflang={%L},"
      "pdfborder=0 0 0}")
    "\n")))
#+END_SRC

Add links in footnotes.
#+BEGIN_SRC emacs-lisp
(defvar org-export-latex-add-link-footnotes t
  "If non-nil links will be added as footnotes if exported to latex.")

(defun +org-export-latex-link-footnote (text backend info)
  "Create a footnote in latex for each link. So when printed the information isn't lost."
  (when (and org-export-latex-add-link-footnotes
             (org-export-derived-backend-p backend 'latex)
             (string-match "\\\\href{\\(.*\\)}{\\(.*\\)}" text))
    (when (some (lambda (type)
                  (string-prefix-p type (match-string 1 text)))
                '("http" "https" "ftp" "mailto" "doi"))
      (format "%s \\footnote{\\url{%s}} " text (match-string 1 text)))))

(with-eval-after-load 'ox
  (cl-pushnew #'+org-export-latex-link-footnote org-export-filter-link-functions :test #'equal))
#+END_SRC

** ansible
#+BEGIN_SRC emacs-lisp
(use-package ansible
  :minor
  "site\\.yml$"
  "roles/.+\\.yml$"
  :magic-minor
  "^\\(---\n\\)?\\(#.*\n\\)* *-? \\(environment\\|h\\(?:\\(?:andler\\|ost\\)s\\)\\|i\\(?:mport_tasks\\|nclude\\(?:_tasks\\)?\\)\\|p\\(?:\\(?:ost\\|re\\)_tasks\\)\\|roles?\\|tasks\\|vars\\(?:_\\(?:files\\|prompt\\)\\)?\\):")

(use-package ansible-doc
  :diminish ansible-doc-mode
  :hook (ansible . ansible-doc-mode)
  :preface
  (defun ansible-doc-at-point ()
    "Ansible doc with selected point"
    (interactive)
    (ansible-doc (thing-at-point 'symbol)))
  :general
  (:keymaps
   'ansible::key-map
   "M-g k" 'ansible-doc-at-point))
#+END_SRC

** clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC

*** Packages
**** cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :hook
  (cider-mode . cider-auto-test-mode)
  :custom
  (cider-prompt-for-symbol nil)
  (cider-repl-display-help-banner nil)
  (cider-repl-history-file (concat +data-dir "cider-history"))
  (org-babel-clojure-backend 'cider)
  :general
  (:keymaps
   'cider-mode-map
   :prefix +local-leader-key
   "c" 'cider-refresh
   "t" 'cider-test-run-test
   "T" 'cider-test-run-ns-tests
   "s" 'cider-test-run-project-tests))
#+END_SRC

** crystal
#+BEGIN_SRC emacs-lisp
(use-package crystal-mode
  :general
  (:keymaps
   'crystal-mode-map
   :prefix +local-leader-key
   "t" 'crystal-spec-line
   "T" 'crystal-spec-buffer
   "s" 'crystal-spec-all))
#+END_SRC

*** Packages
**** inf-crystal
#+BEGIN_SRC emacs-lisp
(use-package inf-crystal
  :hook
  (crystal-mode . inf-crystal-minor-mode)
  :general
  (:keymaps
   'crystal-mode-map
   :prefix +local-leader-key
   "r" 'inf-crystal))
#+END_SRC

** csv
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :custom
  (csv-separators '("," "\t" ";")))
#+END_SRC

** elasticsearch
#+BEGIN_SRC emacs-lisp
(use-package es-mode)
#+END_SRC

** elixir
#+BEGIN_SRC emacs-lisp
(use-package elixir-mode)
#+END_SRC

*** Packages
**** alchemist
#+BEGIN_SRC emacs-lisp
(use-package alchemist
  :hook
  (elixir-mode . alchemist-mode)
  :general
  (:keymaps
   'alchemist-mode-map
   "M-g k" 'alchemist-help-search-at-point)
  (:keymaps
   'alchemist-mode-map
   :prefix +local-leader-key
   "r" 'alchemist-iex-run
   "s" 'alchemist-mix-test
   "t" 'alchemist-mix-test-at-point
   "T" 'alchemist-mix-test-this-buffer))
#+END_SRC

** elm
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :custom
  (elm-format-on-save t)
  (elm-package-json "elm.json")
  (elm-tags-exclude-elm-stuff nil)
  (elm-tags-on-save t)
  :general
  (:keymaps
   'elm-mode-map
   :prefix +local-leader-key
   "t" 'elm-test-project))
#+END_SRC

** epub
*** Packages
**** nov
#+BEGIN_SRC emacs-lisp
(use-package nov
  :mode
  ("\\.epub$" . nov-mode)
  :hook
  (nov-mode . +nov-delayed-render-setup)
  (nov-mode . +nov-fringes-setup)
  :custom
  (nov-save-place-file (concat +data-dir "nov-places"))
  :preface
  (defun +nov-delayed-render-setup ()
    (run-with-idle-timer 0.2 nil 'nov-render-document))

  (defun +nov-fringes-setup ()
    "Hide the fringes for `nov-mode'."
    (set-window-fringes (get-buffer-window) 0 0 nil)))
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(use-package erlang
  :hook
  (erlang-mode . +erlang-eunit-setup)
  (erlang-mode . +erlang-flymake-setup)
  :general
  (:keymaps
   'erlang-mode-map
   "M-g k" 'erlang-man-function)
  (:keymaps
   'erlang-mode-map
   :prefix +local-leader-key
   "t" 'erlang-eunit-compile-and-run-current-test
   "T" 'erlang-eunit-compile-and-run-module-tests
   "r" 'erlang-shell-display)
  :preface
  (defun +erlang-eunit-setup ()
    "Setup EUnit support for `erlang-mode'."
    (require 'erlang-eunit))
  (defun +erlang-flymake-setup ()
    "Setup `flymake' support for `erlang-mode'."
    (require 'erlang-flymake)
    (flymake-mode 1)))
#+END_SRC

*** Packages
**** ivy-erlang-complete
#+BEGIN_SRC emacs-lisp
(use-package ivy-erlang-complete
  :hook
  (erlang-mode . ivy-erlang-complete-init)
  (erlang-mode . +erlang-ivy-completion-setup)
  :preface
  (defun +erlang-ivy-completion-setup ()
    "Setup completion via `ivy' for `erlang-mode'."
    (add-hook 'after-save-hook #'ivy-erlang-complete-reparse nil t)))
#+END_SRC

** git
*** Packages
**** gitignore-mode
#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :mode
  ("/\\.dockerignore$" . gitignore-mode))
#+END_SRC

** go
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :hook
  (go-mode . +go-prettify-symbols-setup)
  :custom
  (gofmt-command "goimports")
  :general
  (:keymaps
   'go-mode-map
   "M-g k" 'godoc-at-point)
  :preface
  (defun +go-prettify-symbols-setup ()
    (dolist (symbol '(("funct"  . ?ƒ)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** go-eldoc
#+BEGIN_SRC emacs-lisp
(use-package go-eldoc
  :hook
  (go-mode . go-eldoc-setup))
#+END_SRC

**** gorepl-mode
#+BEGIN_SRC emacs-lisp
(use-package gorepl-mode
  :hook
  (go-mode . gorepl-mode))
#+END_SRC

** groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode)
#+END_SRC

** fish
#+BEGIN_SRC emacs-lisp
(use-package fish-mode)
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :hook
  (haskell-mode . interactive-haskell-mode)
  :custom
  (haskell-font-lock-symbols t)
  (haskell-process-auto-import-loaded-modules t)
  (haskell-process-log t)
  (haskell-process-show-debug-tips nil)
  (haskell-process-use-presentation-mode t)
  (haskell-stylish-on-save t)
  (haskell-mode-stylish-haskell-path "brittany")
  :general
  (:keymaps
   'interactive-haskell-mode-map
   "M-." 'nil)
  (:keymaps
   'haskell-mode-map
   :prefix +local-leader-key
   "r" 'haskell-interactive-switch
   "R" 'haskell-session-change-target)
  :init
  ;; Allow configuring project local cabal repl commands.
  (put 'haskell-process-args-cabal-repl 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))
#+END_SRC

*** REPL
Persist REPL history.
#+BEGIN_SRC emacs-lisp
(defvar +haskell-interactive-global-history nil)
(with-eval-after-load 'savehist
  (cl-pushnew '+haskell-interactive-global-history savehist-additional-variables :test #'equal))

(defun +haskell-interactive-load-history ()
  "Restore `haskell-interactive-mode' history."
  (add-hook 'kill-buffer-hook #'+haskell-interactive-save-history nil t)
  (when +haskell-interactive-global-history
    (setq haskell-interactive-mode-history +haskell-interactive-global-history)))

(defun +haskell-interactive-save-history ()
  "Save `haskell-interactive-mode' history."
  (setq +haskell-interactive-global-history haskell-interactive-mode-history))

(add-hook 'haskell-interactive-mode-hook #'+haskell-interactive-load-history)
#+END_SRC

*** Packages
**** hasky-stack
#+BEGIN_SRC emacs-lisp
(use-package hasky-stack
  :general
  (:keymaps
   'haskell-mode-map
   :prefix +local-leader-key
   "t" 'hasky-stack-test))
#+END_SRC

** java
*** Packages
**** gradle-mode
#+BEGIN_SRC emacs-lisp
(use-package gradle-mode
  :hook
  ((java-mode kotlin-mode) . gradle-mode)
  :general
  (:keymaps
   'gradle-mode-map
   :prefix +local-leader-key
   "t" 'gradle-test))
#+END_SRC

**** java-lookup
#+BEGIN_SRC emacs-lisp
(use-package javadoc-lookup
  :general
  (:keymaps
   'java-mode-map
   "M-g k" 'javadoc-lookup))
#+END_SRC

** js
#+BEGIN_SRC emacs-lisp
(use-package js-mode
  :hook
  (js-mode . +js-find-file-setup)
  (js-mode . +js-prettify-symbols-setup)
  :preface
  (defun +js-find-file-setup ()
    "Setup `ff-test-find-other-file' support for `js-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__")))

  (defun +js-prettify-symbols-setup ()
    (dolist (symbol '(("=="        . ?≈)
                      ("!="        . "≈/")
                      ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                      ("function"  . ?ƒ)
                      ("let"       . ?ν)
                      ("const"     . "ν_")
                      ("undefined" . ?∅)
                      ("Infinity"  . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** flymake-eslint
#+BEGIN_SRC emacs-lisp
(use-package flymake-eslint
  :init
  (cl-pushnew '(flymake-eslint-enable) safe-local-eval-forms :test #'equal)
  (put 'flymake-eslint-executable-name 'safe-local-variable #'(lambda (x) (member x '("eslint" "eslint_d"))))
  (put 'flymake-eslint-executable-args 'safe-local-variable 'stringp))
#+END_SRC

**** indium
Debugger
#+BEGIN_SRC emacs-lisp
(use-package indium
  :diminish indium-interaction-mode
  :hook
  (js-mode . +indium-interaction-unless-json-mode)
  :commands
  (indium-interaction-mode)
  :preface
  (defun +indium-interaction-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (indium-interaction-mode)))
  :general
  (:keymaps
   'js-mode-map
   :prefix +local-leader-key
   "s" 'indium-scratch
   "o" 'indium-launch
   "O" 'indium-connect)
  (:keymaps
   'indium-debugger-mode
   :definer 'minor-mode
   "RET" 'indium-debugger-step-over))
#+END_SRC

**** jest
Test framework execution.
#+BEGIN_SRC emacs-lisp
(use-package jest
  :general
  (:keymaps
   'js-mode-map
   :prefix +local-leader-key
   "t" 'jest-funcion-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+END_SRC

**** js2
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :hook
  (js-mode . js2-minor-mode)
  :custom
  (js2-highlight-external-variables nil)
  (js2-mode-show-parse-errors nil)
  (js2-skip-preprocessor-directives t)
  (js2-strict-missing-semi-warning nil)
  (js2-strict-trailing-comma-warning nil))
#+END_SRC

**** js2-refactor
Refactor utils, also a dependecy for =indium= debugger.
#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
  :diminish js2-refactor-mode
  :hook
  (js2-minor-mode . js2-refactor-mode))
#+END_SRC

**** nodejs-repl
REPL for nodejs.
#+BEGIN_SRC emacs-lisp
(use-package nodejs-repl)
#+END_SRC

** json
#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :preface
  (defun +json-mode-setup-flymake ()
    "Setup `json-mode' integration with Flymake."
    (add-hook 'flymake-diagnostic-functions #'flymake-check-jsonlint nil t)
    (flymake-mode))
  :hook
  (json-mode . +json-mode-setup-flymake))
#+END_SRC

*** Syntax checker
#+BEGIN_SRC emacs-lisp
(flymake-quickdef-backend flymake-check-jsonlint
  :pre-let ((jsonlint-exec (executable-find "jsonlint")))
  :pre-check (unless jsonlint-exec (error "Cannot find jsonlint executable"))
  :write-type 'file
  :proc-form (list jsonlint-exec "-c" "-q" fmqd-temp-file)
  :search-regexp "^\\(.+\\)\: line \\([0-9]+\\), col \\([0-9]+\\), \\(.+\\)$"
  :prep-diagnostic
  (let* ((lnum (string-to-number (match-string 2)))
         (col (string-to-number (match-string 3)))
         (msg (match-string 4))
         (pos (flymake-diag-region fmqd-source lnum col))
         (beg (car pos))
         (end (cdr pos))
         (type :error))
    (list fmqd-source beg end type msg)))
#+END_SRC

*** Packages
**** json-navigator
#+BEGIN_SRC emacs-lisp
(use-package json-navigator
  :general
  (:keymaps
   'json-mode-map
   :prefix +local-leader-key
   "n" 'json-navigator-navigate-region))
#+END_SRC

** jsx
React JSX support.
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :mode
  "\\.jsx$"
  :magic
  ("\\(import.*from \'react\';?\\|\/\/ @flow\nimport.*from \'react\';?\\)" . rjsx-mode)
  :general
  (:keymaps
   'rjsx-mode-map
   :prefix +local-leader-key
   "R" 'rjsx-rename-tag-at-point))
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)
#+END_SRC

** lisp
*** Packages
**** slime
#+BEGIN_SRC emacs-lisp
(use-package slime
  :hook
  (lisp-mode . slime-mode)
  :custom
  (inferior-lisp-program "sbcl")
  (slime-contribs '(slime-fancy slime-repl))
  :general
  (:keymaps
   'slime-mode-map
   "M-g k" 'slime-describe-symbol)
  (:keymaps
   'slime-mode-map
   :prefix +local-leader-key
   "o" 'slime
   "t" 'slime-load-file-and-other-file)
  :preface
  (defun slime-load-file-and-other-file ()
    "Load buffer file and then load other (test) file."
    (interactive)
    (dolist (file `(,buffer-file-name ,(ff-test-other-file-name)))
      (when (and file (file-exists-p file))
        (slime-load-file file)))))
#+END_SRC

** lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :hook
  (lua-mode . +lua-prettify-symbols-setup)
  :custom
  (lua-documentation-function 'eww)
  :general
  (:keymaps
   'lua-mode-map
   "M-g k" 'lua-search-documentation)
  :preface
  (defun +lua-prettify-symbols-setup ()
    (dolist (symbol '(("~="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠))
                      ("function"  . ?ƒ)
                      ("math.huge" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :hook
  (markdown-mode . auto-fill-mode)
  :custom
  (markdown-enable-wiki-links t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-header-scaling t)
  (markdown-hide-markup t)
  (markdown-italic-underscore t)
  (markdown-make-gfm-checkboxes-buttons t)
  :general
  (:keymaps
   'markdown-mode-map
   :prefix +local-leader-key
   "v" 'markdown-toggle-markup-hiding))
#+END_SRC

*** Packages
**** edit-indirect
Editing regions in separate buffers.
#+BEGIN_SRC emacs-lisp
(use-package edit-indirect)
#+END_SRC

**** markdown-toc
Generate Table of Contents.
#+BEGIN_SRC emacs-lisp
(use-package markdown-toc)
#+END_SRC

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'markdown-mode
 '(("^[[:space:]-*+>]+" 0 'fixed-pitch append))
 'append)
#+END_SRC

**** Bullet lists
Pretty check-boxes
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'markdown-mode
 '(("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

** nginx
#+BEGIN_SRC emacs-lisp
(use-package nginx-mode)
#+END_SRC

** nix
#+BEGIN_SRC emacs-lisp
(use-package nix-mode)
#+END_SRC

*** Packages
**** nix-update
#+BEGIN_SRC emacs-lisp
(use-package nix-update
  :general
  (:keymaps
   'nix-mode-map
   :prefix +local-leader-key
   "u" 'nix-update-fetch))
#+END_SRC

** nxml
#+BEGIN_SRC emacs-lisp
(use-package nxml-mode
  :mode "\\.plist$"
  :custom
  (nxml-slash-auto-complete-flag t)
  :config
  (with-eval-after-load 'smartparens
    (sp-local-pair '(nxml-mode) "<" ">" :actions :rem)))
#+END_SRC

** ocaml
#+BEGIN_SRC emacs-lisp
(use-package caml)

(use-package tuareg
  :general
  (:keymaps
   'tuareg-mode-map
   "C-x C-e" 'tuareg-eval-phrase)
  (:keymaps
   'tuareg-mode-map
   :prefix +local-leader-key
   "r" 'run-ocaml))
#+END_SRC

** pdf
*** Packages
**** pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf$" . pdf-view-mode))
#+END_SRC

** plantuml
#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :custom
  (plantuml-default-exec-mode 'executable))
#+END_SRC

** protobuf
#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode)
#+END_SRC

** python
#+BEGIN_SRC emacs-lisp
(use-package python
  :hook
  (python-mode . +python-prettify-symbols-setup)
  :general
  (:keymaps
   'python-mode-map
   :prefix +local-leader-key
   "r" 'run-python)
  :preface
  (defun +python-prettify-symbols-setup ()
    (dolist (symbol '(("def"      . ?ƒ)
                      ("sum"      . ?Σ)
                      ("not"      . ?￢)
                      ("in"       . ?∈)
                      ("for"      . ?∀)
                      ("**2"      . ?²)
                      ("**3"      . ?³)
                      ("None"     . ?∅)
                      ("math.inf" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** pip-requirements
Editing pip requirements files.
#+BEGIN_SRC emacs-lisp
(use-package pip-requirements)
#+END_SRC

**** pydoc
#+BEGIN_SRC emacs-lisp
(use-package pydoc
  :general
  (:keymaps
   'python-mode-map
   "M-g k" 'pydoc-at-point))
#+END_SRC

**** python-test
#+BEGIN_SRC emacs-lisp
(use-package python-test
  :custom
  (python-test-backend 'pytest)
  :general
  (:keymaps
   'python-mode-map
   :prefix +local-leader-key
   "t" 'python-test-project)
  :config
  (setq python-test-project-root-files
        (append '("README.md") python-test-project-root-files)))
#+END_SRC

** racket
#+BEGIN_SRC emacs-lisp
(use-package racket-mode
  :general
  (:keymaps
   'racket-mode-map
   "M-g k" 'racket-doc)
  (:keymaps
   'racket-mode-map
   :prefix +local-leader-key
   "t" 'racket-test))
#+END_SRC

*** Packages
**** flymake-racket
#+BEGIN_SRC emacs-lisp
(use-package flymake-racket
  :hook
  (racket-mode . flymake-racket-add-hook))
#+END_SRC

** rst
#+BEGIN_SRC emacs-lisp
(use-package rst
  :hook
  (rst-mode . auto-fill-mode)
  :preface
  (defvar rst-adornment-regexp nil
    "Regular expression to match adornments.")
  :config
  (setq rst-adornment-regexp
        (concat "^[" rst-adornment-chars "]\\{3,\\}$")))
#+END_SRC

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'rst-mode
 '(("^[[:space:]-*+]+\\(\\[.\\]\\)?" 0 'fixed-pitch append))
 'append)
#+END_SRC

**** Heading
Hide heading adornments.
#+BEGIN_SRC emacs-lisp
(defun +rst-hide-heading-adornment ()
  "Hide heading adornment for `rst-mode'."
  (interactive)
  (hide-lines-matching rst-adornment-regexp))
(add-hook 'rst-mode-hook #'+rst-hide-heading-adornment)
#+END_SRC

**** Bullet lists
Pretty check-boxes as well as bullet lists.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'rst-mode
 '(("^ *\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
   ("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

** ruby
#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :hook
  (ruby-mode . +ruby-find-file-setup)
  (ruby-mode . +ruby-prettify-symbols-setup)
  :custom
  (ruby-align-chained-calls t)
  :preface
  (defun +ruby-find-file-setup ()
    "Setup `ff-test-find-other-file' support for `ruby-mode'."
    (setq ff-test-suffixes '("_test" "_spec")
          ff-test-search-implementation-project-directories '("app" "lib")
          ff-test-search-test-project-directories '("test" "spec")))

  (defun +ruby-prettify-symbols-setup ()
    (dolist (symbol '(("def"             . ?ƒ)
                      ("Float::INFINITY" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
  :config
  (with-eval-after-load 'hideshow
    (cl-pushnew `(ruby-mode
                  ,(rx (or "def" "class" "module" "do" "{" "[")) ; Block start
                  ,(rx (or "}" "]" "end"))                       ; Block end
                  ,(rx bol
                       (or (+ (zero-or-more blank) "#") "=begin")) ; Comment start
                  ruby-forward-sexp nil)
                hs-special-modes-alist
                :test #'equal)))
#+END_SRC

*** Testing
#+BEGIN_SRC emacs-lisp
(defun ruby-test-all ()
  "Test all files using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-all)
    (minitest-verify-all)))

(defun ruby-test-file ()
  "Test current file using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify)
    (minitest-verify)))

(defun ruby-test-at-point ()
  "Test definition at point using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-single)
    (minitest-verify-single)))

(general-define-key
 :keymaps 'ruby-mode-map
 :prefix +local-leader-key
 "t" 'ruby-test-at-point
 "T" 'ruby-test-file
 "s" 'ruby-test-all)
#+END_SRC

*** Packages
**** inf-ruby
#+BEGIN_SRC emacs-lisp
(use-package inf-ruby
  :hook
  (ruby-mode . inf-ruby-minor-mode)
  ;; Auto breakpoint
  (compilation-filter . inf-ruby-auto-enter)
  :custom
  (inf-ruby-default-implementation "pry")
  :general
  (:keymaps
   'ruby-mode-map
   :prefix +local-leader-key
   "r" 'inf-ruby))
#+END_SRC

**** minitest
#+BEGIN_SRC emacs-lisp
(use-package minitest
  :hook
  (ruby-mode . minitest-enable-appropriate-mode))
#+END_SRC

**** rake
#+BEGIN_SRC emacs-lisp
(use-package rake
  :custom
  (rake-completion-system 'default)
  (rake-cache-file (expand-file-name "rake.cache" +cache-dir)))
#+END_SRC

**** rspec-mode
#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :hook
  (ruby-mode . rspec-enable-appropriate-mode)
  :custom
  (rspec-use-relative-path t)
  (rspec-use-opts-file-when-available nil)
  (rspec-command-options "--format progress"))
#+END_SRC

**** rubocopfmt
#+BEGIN_SRC emacs-lisp
(use-package rubocopfmt
  :diminish rubocopfmt-mode
  :hook
  (ruby-mode . rubocopfmt-mode)
  :custom
  (rubocopfmt-use-bundler-when-possible nil)
  :general
  (:keymaps
   'ruby-mode-map
   :prefix +local-leader-key
   "f" 'rubocopfmt-mode))
#+END_SRC

**** ruby-refactor
#+BEGIN_SRC emacs-lisp
(use-package ruby-refactor
  :diminish ruby-refactor-mode
  :hook
  (ruby-mode . ruby-refactor-mode))
#+END_SRC

**** yard-mode
#+BEGIN_SRC emacs-lisp
(use-package yard-mode
  :diminish yard-mode
  :hook ruby-mode)
#+END_SRC

**** yari
#+BEGIN_SRC emacs-lisp
(use-package yari
  :general
  (:keymaps
   'ruby-mode-map
   "M-g k" 'yari)
  (:keymaps
   'help-command-map
   "R" 'yari))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rustic
  :custom
  (rustic-rls-pkg 'eglot)
  :general
  (:keymaps
   'rustic-mode-map
   :prefix +local-leader-key
   "t" 'rustic-cargo-test)
  :init
  (with-eval-after-load 'org
    (cl-pushnew '("rust" . rustic) org-src-lang-modes :test #'equal))
  :config
  (require 'eglot))
#+END_SRC

** salt
#+BEGIN_SRC emacs-lisp
(use-package salt-mode
  :general
  (:keymaps
   'salt-mode-map
   "M-g k" 'salt-mode-browse-doc))
#+END_SRC

** scala
#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :hook
  (scala-mode . +scala-prettify-symbols-setup)
  :custom
  (scala-indent:align-parameters t)
  :preface
  (defun +scala-prettify-symbols-setup ()
    (setq prettify-symbols-alist scala-prettify-symbols-alist)))
#+END_SRC

*** Packages
**** sbt-mode
#+BEGIN_SRC emacs-lisp
(use-package sbt-mode)
#+END_SRC

** sh
#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :custom
  ;; Use regular indentation for line-continuation
  (sh-indent-after-continuation 'always)
  :general
  (:keymaps
   'sh-mode-map
   "M-g k" 'man))
#+END_SRC

*** Packages
**** flymake-shellcheck
#+BEGIN_SRC emacs-lisp
(use-package flymake-shellcheck
  :hook
  (sh-mode . flymake-mode)
  (sh-mode . flymake-shellcheck-load))
#+END_SRC

** sql
#+BEGIN_SRC emacs-lisp
(use-package sql
  :custom
  (sql-mysql-options '("--protocol=tcp" "--prompt=" "--disable-pager")))
#+END_SRC

** term
#+BEGIN_SRC emacs-lisp
(use-package term
  :hook
  (term . turn-off-truncate-lines)
  :custom
  (explicit-shell-file-name "fish")
  :general
  (:prefix
   +launch-prefix
   "T" 'term))
#+END_SRC

** typescript
#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :hook
  (typescript-mode . +typescript-find-file-setup)
  (typescript-mode . +typescript-prettify-symbols-setup)
  :preface
  (defun +typescript-find-file-setup ()
    "Setup `ff-test-find-other-file' support for `typescript-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__")))

  (defun +typescript-prettify-symbols-setup ()
    (dolist (symbol '(("=="        . ?≈)
                      ("!="        . "≈/")
                      ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                      ("function"  . ?ƒ)
                      ("let"       . ?ν)
                      ("const"     . "ν_")
                      ("null"      . ?∅)
                      ("Infinity"  . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** ts-comint
TypeScript REPL.
#+BEGIN_SRC emacs-lisp
(use-package ts-comint
  :custom
  (ts-comint-program-command "ts-node"))
#+END_SRC

**** jest
Test framework execution.
#+BEGIN_SRC emacs-lisp
(use-package jest
  :general
  (:keymaps
   'typescript-mode-map
   :prefix +local-leader-key
   "t" 'jest-function-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+END_SRC

** web
*** Packages
**** cakecrumbs
Display current path for HTML/XML/CSS.
#+BEGIN_SRC emacs-lisp
(use-package cakecrumbs
  :config
  (cakecrumbs-auto-setup))
#+END_SRC

**** emmet-mode
Snippets and Zen Coding for HTML.
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :hook
  (css-mode
   haml-mode
   html-mode
   nxml-mode
   rjsx-mode
   web-mode)
  (rjsx-mode . +emmet-use-jsx-className)
  :custom
  (emmet-move-cursor-between-quotes t)
  :preface
  (defun +emmet-use-jsx-className ()
    "Set `emmet-expand-jsx-className?' as local variable."
    (setq-local emmet-expand-jsx-className? t)))
#+END_SRC

**** pug-mode
#+BEGIN_SRC emacs-lisp
(use-package pug-mode)
#+END_SRC

**** slim-mode
#+BEGIN_SRC emacs-lisp
(use-package slim-mode)
#+END_SRC

**** web-mode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode
  "\\.\\(phtml\\|php\\|[agj]sp\\|as[cp]x\\|erb\\|djhtml\\|html?\\|hbs\\|ejs\\|jade\\|swig\\|tmpl\\)$"
  :custom
  (web-mode-enable-html-entities-fontification t)
  ;; Highlight enclosing tags of the element under cursor
  (web-mode-enable-current-element-highlight t)
  ;; No extra indentation for blocks.
  (web-mode-script-padding 0)
  (web-mode-style-padding 0))
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :hook (yaml-mode . indent-guide-mode))
#+END_SRC

* Tools
** E-mail
*** Packages
**** bbdb
Store contacts.
#+BEGIN_SRC emacs-lisp
(use-package bbdb)
#+END_SRC

**** gmail2bbdb
Import contacts from Gmail vCard data.
#+BEGIN_SRC emacs-lisp
(use-package gmail2bbdb
  :config
  (setq gmail2bbdb-bbdb-file bbdb-file
        gmail2bbdb-exclude-people-without-name t))
#+END_SRC

** Focus
Dim out the surrounding text except the current focused paragraph or expression.
#+BEGIN_SRC emacs-lisp
(use-package focus
  :diminish focus-mode)
#+END_SRC

** Indentation guides
#+BEGIN_SRC emacs-lisp
(use-package indent-guide
  :diminish indent-guide-mode
  :custom
  (indent-guide-char "\x2502"))
#+END_SRC

** Pomodoro
#+BEGIN_SRC emacs-lisp
(use-package redtick
  :general
  (:prefix
   +launch-prefix
   "r" 'redtick))
#+END_SRC

** Recording
#+BEGIN_SRC emacs-lisp
(use-package camcorder
  :custom
  (output-directory (getenv "XDG_VIDEOS_DIR"))
  (gif-output-directory (getenv "XDG_VIDEOS_DIR"))
  :general
  (:prefix
   +launch-prefix
   "c" 'camcorder-record))
#+END_SRC

** Session
Support for restoring previous session on Emacs restart. This adds a few tweaks that makes
it really useful.
- Support for persistent undo history via =buffer-indo-list=.
- Ignore saving of =gz= files as it seems not to properly load those.
- Only restore 5 files to begin with to avoid slow starts with huge sessions.
#+BEGIN_SRC emacs-lisp
(use-package desktop
  :demand t
  :custom
  (desktop-files-not-to-save "\\(\\`/[^/:]*:\\|(ftp)\\|\\.gz\\'\\)")
  (desktop-restore-eager 0)
  (desktop-save (daemonp))
  (desktop-load-locked-desktop (daemonp))
  :preface
  (defun +append-buffer-undo-list-to-buffer-local-variables-advice (orig-fn &rest args)
    "Override `buffer-local-variables' and call ORIG-FN with ARGS.
  There is a bug in Emacs where the `buffer-undo-list' data is
  missing from the output of `buffer-local-variables'. This
  advice temporarily overrides the function and appends the
  missing data."
    (let ((orig-buffer-local-variables-fn (symbol-function 'buffer-local-variables)))
      (cl-letf (((symbol-function 'buffer-local-variables)
                 #'(lambda () (append (funcall orig-buffer-local-variables-fn)
                                      `(,(cons 'buffer-undo-list buffer-undo-list))))))
        (apply orig-fn args))))
  :config
  (advice-add #'desktop-buffer-info :around #'+append-buffer-undo-list-to-buffer-local-variables-advice)

  (cl-pushnew 'buffer-undo-list desktop-locals-to-save :test #'equal)
  (cl-pushnew 'ivy-views desktop-globals-to-save :test #'equal)

  (desktop-save-mode 1))
#+END_SRC

** Spell checking
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :diminish flyspell-mode
  :hook
  ((text-mode message-mode) . flyspell-mode)
  (prog-mode . flyspell-prog-mode)
  :general
  (:keymaps
   'flyspell-mode-map
   "C-," 'nil
   "C-." 'nil))
#+END_SRC

Automatically infer dictionary.
#+BEGIN_SRC emacs-lisp
(use-package auto-dictionary)
#+END_SRC

** Undo
Navigate through undo history.
#+BEGIN_SRC emacs-lisp
(use-package undo-propose
  :general
  (:prefix
   +launch-prefix
   "u" 'undo-propose))
#+END_SRC

* Private
#+BEGIN_SRC emacs-lisp
(require 'private nil t)
#+END_SRC

* The end
#+BEGIN_SRC emacs-lisp
(provide 'init)
;;; init.el ends here
#+END_SRC

* Tasks
** TODO Look into skewer packages
** TODO Look into modal editing with =objed=
** TODO Look into generic code execution via =isend-mode=
** TODO Add binding for org-noter
** TODO Group editing bindings under some logical prefix
** TODO Improve window keys
** TODO Improve find char keys
** TODO Override =M-n= with something useful?
** TODO Override =M-p= with something useful?
** TODO Easier way to toggle =subword-mode=
** TODO Easier way to toggle =glasses-mode=
** TODO Extract history persistance code (persistory)
  - comint
  - ielm (via comint and savehist)
  - haskell-interactive (via savehist)
** TODO Enable auto-revert/save again?
** TODO Wrap lines by default?
  When writing code on a single line, to later let it be expanded by the formatter.
** TODO Only scale images that are larger than size X in org mode
** TODO Add support for special =TODO= face in org
** TODO Fix e-mail address
** TODO Bind =sp-wrap-around=
** TODO Use =ielm= as REPL for org-mode
** TODO Use file-name as base for work-log date
** TODO Daily tasks
